/*
Copyright (C) 2020 Prashant Shah <pshah.crb@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

%require  "3.0"
%skeleton "lalr1.cc"

%code requires {
	#include "ast.h"
	namespace yy {
		class Lexer;  // Generated by reflex with namespace=yy lexer=Lexer lex=yylex
	}
}

%defines
%locations
%parse-param { yy::Lexer& lexer }  // Construct parser object with lexer
%define api.value.type variant

%code {
	#include <typeinfo>
	#include <limits>
	#include "ast.h"
	#include "lex.yy.h"  // header file generated with reflex --header-file
	#undef yylex
	#define yylex lexer.yylex  // Within bison's parse() we should invoke lexer.yylex(), not the global yylex()

	// #define DEBUG(str) std::cout << str << "\n"
	#define DEBUG(str)
	#define ERR(str) std::cout << str
	#define ALERT(str) std::cout << "\n" \
		<< "**********************************************" << "\n" \
		<< "                   " << str << "\n" \
		<< "**********************************************" << "\n";

	SourceFile sf;

	// LLVMContext owns a lot of core LLVM data structures, such as the type and constant value tables.
	llvm::LLVMContext Context;
	// IRBuilder is a helper to generate LLVM instructions
	llvm::IRBuilder<> Builder(Context);
	// Top level structure that contains functions and global variables
	std::unique_ptr<llvm::Module> Module;
	// Basic block
	llvm::BasicBlock *BB;
}

%token <int> NAMESAPCE
%token <int> IMPORT FROM AS
%token <std::string> STR1_LITERAL STR2_LITERAL RSTR1_LITERAL RSTR2_LITERAL
%token <std::string> HSTR1_LITERAL HSTR2_LITERAL HRSTR1_LITERAL HRSTR2_LITERAL
%token <int> FUNC_RETURN
%token <std::string> IDENTIFIER
%token <int> DEF
%token <int> BOOL CHAR BYTE
%token <int> INT INT8 INT16 INT32 INT64 UINT UINT8 UINT16 UINT32 UINT64
%token <int> FLOAT32 FLOAT64 FLOAT128
%token <int> STRING
%token <int> POINTER
%token <int> GENERIC_POINTER
%token <int> AUTO
%token <int> TYPE
%token <int> STRUCT UNION ENUM
%token <int> EXTEND
%token <int> TRUE FALSE
%token <int> PTR_NULL
%token <int> REGISTER STATIC
%token <int> CONST VOLATILE RESTRICT ATOMIC CONST_RESTRICT
%token <std::string> BINARY_LIT OCTAL_LIT DECIMAL_LIT HEX_LIT
%token <std::string> FLOAT_LIT CHAR_LIT

%token <int> EQUAL_TO
%token <int> PLUS MINUS MULTIPLY_OR_DEREF DIVIDE MODULUS
%token <int> RIGHT_SHIFT LEFT_SHIFT RIGHT_SHIFT_US LEFT_SHIFT_US
%token <int> IS_EQUAL IS_NOT_EQUAL IS_LESS IS_GREATER IS_LESS_OR_EQ IS_GREATER_OR_EQ
%token <int> LOGICAL_OR LOGICAL_AND
%token <int> BITWISE_AND BITWISE_OR BITWISE_NOT BITWISE_XOR

%token <int> PLUS_EQUAL_TO MINUS_EQUAL_TO MULTIPLY_EQUAL_TO DIVIDE_EQUAL_TO MODULUS_EQUAL_TO
%token <int> RIGHT_SHIFT_EQUAL_TO LEFT_SHIFT_EQUAL_TO RIGHT_SHIFT_US_EQUAL_TO LEFT_SHIFT_US_EQUAL_TO
%token <int> LOGICAL_OR_EQUAL_TO LOGICAL_AND_EQUAL_TO

%token <int> PTR_MEMBER

%token <int> RETURN BREAK CONTINUE GOTO
%token <int> FOR WHILE DO FOREACH IN
%token <int> IF ELSE SWITCH CASE DEFAULT
%token <int> DEFER

%token <int> PUBLIC PRIVATE

%token <int> U_POINTER
%token <int> SCOPE_RESOLUTION

%token <int> TEMPLATE_START TEMPLATE_END

%token <int> EOL

%left PLUS MINUS MULTIPLY_OR_DEREF DIVIDE MODULUS
%left RIGHT_SHIFT LEFT_SHIFT RIGHT_SHIFT_US LEFT_SHIFT_US
%left IS_EQUAL IS_NOT_EQUAL IS_LESS IS_GREATER IS_LESS_OR_EQ IS_GREATER_OR_EQ
%left LOGICAL_OR LOGICAL_AND
%left BITWISE_AND BITWISE_OR BITWISE_NOT BITWISE_XOR
%precedence U_NOT
%precedence U_2COMP
%precedence U_ADD_OF

%precedence "type_cast"

%nterm <int> source_file
%nterm <TopLevel *> top_level
%nterm <ImportDecl *> import_decl
%nterm <FunctionDefn *> func_defn
%nterm <AccessModifier *> access_modifier
%nterm <TypeFunction *> type_func
%nterm <NamespaceDefn *> namespace_defn
%nterm <NamespaceBlockList *> namespace_block_list
%nterm <NamespaceBlock *> namespace_block

%nterm <FunctionDefnList *> func_defn_list

%nterm <Storage *> storage_class
%nterm <TypeQualifier *> type_qualifier
%nterm <TypeName *> type_name
%nterm <Type *> type
%nterm <Block *> block

%nterm <Statements *> statements
%nterm <Statement *> statement
%nterm <VariableDef *> variable_def
%nterm <IterationStmt *> iteration
%nterm <ForStmt *> for_stmt
%nterm <ForInit *> for_init
%nterm <ForCondition *> for_cond
%nterm <ForPost *> for_post
%nterm <WhileStmt *> while_stmt
%nterm <DoWhileStmt *> dowhile_stmt
%nterm <DeferStmt *> defer_stmt

%nterm <Literal *> literal
%nterm <BooleanLiteral *> bool_lit
%nterm <IntegerLiteral *> int_lit
%nterm <FloatLiteral *> float_lit
%nterm <CharLiteral *> char_lit
%nterm <StringLiteral *> str_lit
%nterm <PointerLiteral * > ptr_lit
%nterm <CompositeLiteral *> composite_lit
%nterm <CompositeTypeDefn *> composite_type_defn
%nterm <StructDefn *> struct_defn
%nterm <UnionDefn *> union_defn
%nterm <EnumDefn *> enum_defn
%nterm <StructUnionFields *> struct_union_fields
%nterm <StructUnionField *> struct_union_field
%nterm <EnumFields *> enum_fields
%nterm <TypeIdentifier *> type_identifier
%nterm <FunctionSign *> func_sign
%nterm <FunctionParam *> func_param
%nterm <FunctionReturn *> func_return

%nterm <SelectionStmt *> selection_stmt
%nterm <IfElseStmt *> if_else_stmt
%nterm <SwitchStmt *> switch_stmt
%nterm <IfBlock *> if_block
%nterm <ElseBlock *> else_block

%nterm <AssignOp *> assign_op
%nterm <LValue *> l_value
%nterm <LValueList *> l_value_list
%nterm <AssignmentStmt *> assignment_stmt

%nterm <Expression *> expression
%nterm <UnaryExpression *> unary_expr
%nterm <BinaryExpression *> binary_expr
%nterm <NameSpaceIdent *> namespace_ident
%nterm <FunctionCallOp *> func_call_op
%nterm <ReturnArgumentList *> return_argument_list
%nterm <CaseBlock *> case_block

%nterm <JumpStmt *> jump_stmt

%start source_file

%%

source_file
		: source_file top_level
						{
							sf.t.push_back($2);
							DEBUG("[SourceFile]");
						}
		| top_level
						{
							sf.t.push_back($1);
							DEBUG("[SourceFile]");
						}
		;

top_level
		: import_decl EOL
						{
							$$ = new TopLevel();
							$$->type = TopLevel::types::IMPORT_DECL;
							$$->id = $1;
							DEBUG("[TopLevel::ImportDecl]");
						}
		| variable_def EOL
						{
							$$ = new TopLevel();
							$$->type = TopLevel::types::VARIABLE_DEF;
							$$->vd = $1;
							$$->vd->is_global = true;
							DEBUG("[TopLevel::VariableDef]");
						}
		| composite_type_defn EOL
						{
							$$ = new TopLevel();
							$$->type = TopLevel::types::COMPOSITE_TYPE_DEFN;
							$$->ctd = $1;
							$$->ctd->is_global = true;
							DEBUG("[TopLevel::CompositeTypeDefn]");
						}
		| type_alias EOL
						{
							$$ = new TopLevel();
							$$->type = TopLevel::types::TYPE_ALIAS;
							// $$->ctd = $1;
							$$->ctd->is_global = true;
							DEBUG("[TopLevel::TypeAlias]");
						}
		| type_func EOL
						{
							$$ = new TopLevel();
							$$->type = TopLevel::types::TYPE_FUNC;
							$$->tf = $1;
							DEBUG("[TopLevel::TypeFunction]");
						}
		| namespace_defn EOL
						{
							$$ = new TopLevel();
							$$->type = TopLevel::types::NAMESPACE_DEFN;
							// $$->fd = $1;
							DEBUG("[TopLevel::NamespaceDefn]");
						}
		| func_defn EOL
						{
							$$ = new TopLevel();
							$$->type = TopLevel::types::FUNC_DEFN;
							$$->fd = $1;
							DEBUG("[TopLevel::FunctionDefn]");
						}
		;

import_decl
		: IMPORT STR1_LITERAL FROM STR1_LITERAL AS STR1_LITERAL
						{
							$$ = new ImportDecl();
							$$->import = $2;
							$$->from = $4;
							$$->as = $6;
							DEBUG("[ImportFromAs]");
						}
		| IMPORT STR1_LITERAL FROM STR1_LITERAL
						{
							$$ = new ImportDecl();
							$$->import = $2;
							$$->from = $4;
							DEBUG("[ImportFrom]");
						}
		| IMPORT STR1_LITERAL
						{
							$$ = new ImportDecl();
							$$->import = $2;
							DEBUG("[Import]");
						}
		;

namespace_defn
		: NAMESAPCE IDENTIFIER '{' namespace_block_list '}'
						{
							$$ = new NamespaceDefn();
							$$->ident = $2;
							$$->nsbl = $4;
							DEBUG("[NS]");
						}
		;

namespace_block_list
		: %empty
						{
							/* empty */
						}
		| namespace_block_list namespace_block
						{
							if (!$1) {
								$1 = new NamespaceBlockList();
							}
							$1->nsbl.push_back($2);
							$$ = $1;
							DEBUG("[NS::BlockList]");
						}
		;

namespace_block
		: variable_def EOL
						{
							$$ = new NamespaceBlock();
							$$->type = NamespaceBlock::types::VARIABLE_DEF;
							$$->vd = $1;
							DEBUG("[NS::VariableDef]");
						}
		| composite_type_defn EOL
						{
							$$ = new NamespaceBlock();
							$$->type = NamespaceBlock::types::COMPOSITE_TYPE_DEFN;
							$$->ctd = $1;
							DEBUG("[NS::CompositeTypeDefn]");
						}
		| type_alias EOL
						{
							$$ = new NamespaceBlock();
							$$->type = NamespaceBlock::types::TYPE_ALIAS;
							// $$->ctd = $1;
							DEBUG("[NS::TypeAlias]");
						}
		| type_func EOL
						{
							$$ = new NamespaceBlock();
							$$->type = NamespaceBlock::types::TYPE_FUNC;
							$$->tf = $1;
							DEBUG("[NS::TypeFunction]");
						}
		| namespace_defn EOL
						{
							$$ = new NamespaceBlock();
							$$->type = NamespaceBlock::types::NAMESPACE_DEFN;
							$$->nd = $1;
							DEBUG("[NS::NamespaceDefn]");
						}
		| func_defn EOL
						{
							$$ = new NamespaceBlock();
							$$->type = NamespaceBlock::types::FUNC_DEFN;
							$$->fd = $1;
							DEBUG("[NS::FunctionDefn]");
						}
		;

func_defn
		: access_modifier DEF IDENTIFIER template func_sign block
						{
							$$ = new FunctionDefn();
							$$->am = $1;
							$$->fn = $3;
							$$->fs = $5;
							$$->b = $6;
							DEBUG("[FunctionDefn::Template]");
						}
		| access_modifier DEF IDENTIFIER func_sign block
						{
							$$ = new FunctionDefn();
							$$->am = $1;
							$$->fn = $3;
							$$->fs = $4;
							$$->b = $5;
							DEBUG("[FunctionDefn]");
						}
		;

access_modifier
		: %empty
						{
							/* empty */
						}
		| PUBLIC
						{
							$$ = new AccessModifier();
							$$->type = AccessModifier::types::PUBLIC;
						}
		| PRIVATE
						{
							$$ = new AccessModifier();
							$$->type = AccessModifier::types::PRIVATE;
						}
		;

func_sign
		: '(' func_param ')' FUNC_RETURN '(' func_return ')'
						{
							$$ = new FunctionSign();
							$$->fp = $2;
							$$->fr = $6;
							DEBUG("[Block]");
						}
		;

block
		: '{' statements '}'
						{
							$$ = new Block();
							$$->s = $2;
							DEBUG("[Block]");
						}
		;

func_param
		: %empty
						{
							$$ = new FunctionParam();
							$$->is_set = false;
							DEBUG("[FunctionParam]");
						}
		| func_param ',' type_identifier
						{
							$1->fpl.push_back($3);
							$$ = $1;
							DEBUG("[FunctionParam]");
						}
		| type_identifier
						{
							$$ = new FunctionParam();
							$$->is_set = true;
							$$->fpl.push_back($1);
							DEBUG("[FunctionParam]");
						}
		;

func_return
		: %empty
						{
							$$ = new FunctionReturn();
							$$->is_set = false;
							DEBUG("[FunctionReturn]");
						}
		| func_return ',' type_identifier
						{
							$1->frl.push_back($3);
							$$ = $1;
							DEBUG("[FunctionReturn]");
						}
		| func_return ',' type
						{
							TypeIdentifier *ti = new TypeIdentifier();
							ti->t = $3;
							ti->ident = "";

							$1->frl.push_back(ti);
							$$ = $1;
							DEBUG("[FunctionReturn]");
						}
		| type_identifier
						{
							$$ = new FunctionReturn();
							$$->is_set = true;
							$$->frl.push_back($1);
							DEBUG("[FunctionReturn]");
						}
		| type
						{
							$$ = new FunctionReturn();
							$$->is_set = true;

							TypeIdentifier *ti = new TypeIdentifier();
							ti->t = $1;
							ti->ident = "";

							$$->frl.push_back(ti);
							DEBUG("[FunctionReturn]");
						}
		;

type_identifier
		: type IDENTIFIER
						{
							$$ = new TypeIdentifier();
							$$->t = $1;
							$$->ident = $2;
							DEBUG("[TypeIdentifier]");
						}
		;

type_func
		: EXTEND type_name '{' func_defn_list '}'
						{
							$$ = new TypeFunction();
							$$->fdl = $4;
							DEBUG("[TypeFunction]");
						}
		;

func_defn_list
		: %empty
						{
							/* empty */
						}
		| func_defn_list func_defn EOL
						{
							if (!$1) {
								$1 = new FunctionDefnList();
								$1->is_set = true;
							}
							$1->fdl.push_back($2);
							$$ = $1;
							DEBUG("[TypeFunction::FunctionDefn]");
						}
		;

/******************************************************************************************/
/************************************** TYPES *********************************************/
/******************************************************************************************/

type
		: storage_class type_qualifier type_name
						{
							$$ = new Type();
							$$->storage = $1;
							$$->type_qualifier = $2;
							$$->type_name = $3;
							DEBUG("[Type->S::Q::T]");
						}
		| storage_class type_name
						{
							$$ = new Type();
							$$->storage = $1;
							$$->type_qualifier = NULL;
							$$->type_name = $2;
							DEBUG("[Type->S::T]");
						}
		| type_qualifier type_name
						{
							$$ = new Type();
							$$->storage = NULL;
							$$->type_qualifier = $1;
							$$->type_name = $2;
							DEBUG("[Type->Q::T]");
						}
		| type_name
						{
							$$ = new Type();
							$$->storage = NULL;
							$$->type_qualifier = NULL;
							$$->type_name = $1;
							DEBUG("[Type->T]");
						}
		;

storage_class
		: REGISTER
						{
							$$ = new Storage();
							$$->storage = Storage::storages::REGISTER;
							DEBUG("[Storage::Register]");
						}
		| STATIC
						{
							$$ = new Storage();
							$$->storage = Storage::storages::STATIC;
							DEBUG("[Storage::Static]");
						}
		;

type_qualifier
		: CONST
						{
							$$ = new TypeQualifier();
							$$->type_qualifier = TypeQualifier::type_qualifiers::CONST;
							DEBUG("[TypeQualifier::Const]");
						}
		| VOLATILE
						{
							$$ = new TypeQualifier();
							$$->type_qualifier = TypeQualifier::type_qualifiers::VOLATILE;
							DEBUG("[TypeQualifier::Volatile]");
						}
		| RESTRICT
						{
							$$ = new TypeQualifier();
							$$->type_qualifier = TypeQualifier::type_qualifiers::RESTRICT;
							DEBUG("[TypeQualifier::Restrict]");
						}
		| ATOMIC
						{
							$$ = new TypeQualifier();
							$$->type_qualifier = TypeQualifier::type_qualifiers::ATOMIC;
							DEBUG("[TypeQualifier::Atomic]");
						}
		| CONST_RESTRICT
						{
							$$ = new TypeQualifier();
							$$->type_qualifier = TypeQualifier::type_qualifiers::CONST_RESTRICT;
							DEBUG("[TypeQualifier::ConstRestrict]");
						}
		;

type_name
		: BOOL
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::BOOL;
							DEBUG("[Type::Bool]");
						}
		| CHAR
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::CHAR;
							DEBUG("[Type::Char]");
						}
		| BYTE
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::BYTE;
							DEBUG("[Type::Byte]");
						}
		| INT
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::INT;
							DEBUG("[Type::Int]");
						}
		| INT8
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::INT8;
							DEBUG("[Type::Int8]");
						}
		| INT16
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::INT16;
							DEBUG("[Type::Int16]");
						}
		| INT32
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::INT32;
							DEBUG("[Type::Int32]");
						}
		| INT64
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::INT64;
							DEBUG("[Type::Int64]");
						}
		| UINT
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::UINT;
							DEBUG("[Type::UInt]");
						}
		| UINT8
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::UINT8;
							DEBUG("[Type::UInt8]");
						}
		| UINT16
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::UINT16;
							DEBUG("[Type::UInt16]");
						}
		| UINT32
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::UINT32;
							DEBUG("[Type::UInt32]");
						}
		| UINT64
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::UINT64;
							DEBUG("[Type::UInt64]");
						}
		| FLOAT32
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::FLOAT32;
							DEBUG("[Type::Float32]");
						}
		| FLOAT64
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::FLOAT64;
							DEBUG("[Type::Float64]");
						}
		| FLOAT128
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::FLOAT128;
							DEBUG("[Type::Float128]");
						}
		| STRING
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::STRING;
							DEBUG("[Type::String]");
						}
		| POINTER ':' type_name
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::POINTER;
							DEBUG("[Type::Pointer]");
						}
		| GENERIC_POINTER
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::GENERIC_POINTER;
							DEBUG("[Type::GenericPointer]");
						}
		| STRUCT IDENTIFIER template
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::STRUCT_TEMPLATE;
							DEBUG("[Type::Struct::Template]");
						}
		| STRUCT IDENTIFIER
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::STRUCT;
							DEBUG("[Type::Struct]");
						}
		| UNION	IDENTIFIER template
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::UNION_TEMPLATE;
							DEBUG("[Type::Union::Template]");
						}
		| UNION	IDENTIFIER
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::UNION;
							DEBUG("[Type::Union]");
						}
		| ENUM IDENTIFIER
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::ENUM;
							DEBUG("[Type::ENUM]");
						}
		| function_type
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::FUNCTION;
							DEBUG("[Function]");
						}
		| IDENTIFIER
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::CUSTOM;
							DEBUG("[Type::CustomType]");
						}
		;

function_type
		: template '(' type_list ')' FUNC_RETURN '(' type_list ')'
						{
						}
		| '(' type_list ')' FUNC_RETURN '(' type_list ')'
						{
						}
		;

type_list
		: %empty
						{
							/* empty */
						}
		| type_list ',' type
						{
						}
		| type
						{
						}
		;


/******************************************************************************************/
/************************************** STATEMENTS ****************************************/
/******************************************************************************************/

statements
		: %empty
						{
							/* empty */
						}
		| statements statement
						{
							if (!$1) {
								$1 = new Statements();
							}
							$1->s.push_back($2);
							$$ = $1;
							DEBUG("[Statements]");
						}
		;

statement
		: variable_def EOL
						{
							$$ = new Statement();
							$$->type = Statement::types::VARIABLE_DEF;
							$$->vds = $1;
							$$->vds->is_global = false;
							DEBUG("[Stmt:VariableDef]");
						}
		| composite_type_defn EOL
						{
							$$ = new Statement();
							$$->type = Statement::types::COMPOSITE_TYPE_DEFN;
							$$->ctds = $1;
							$$->ctds->is_global = false;
							DEBUG("[Stmt:CompositeTypeDefnStmt]");
						}
		| type_alias EOL
						{
							$$ = new Statement();
							$$->type = Statement::types::TYPE_ALIAS;
							// $$->ctd = $1;
							// $$->ctds->is_global = false;
							DEBUG("[Stmt::TypeAlias]");
						}
		| func_call_stmt EOL
						{
							$$ = new Statement();
							$$->type = Statement::types::EXPRESSION;
							// $$->es = &$1;
							DEBUG("[Stmt:ExprStmt]");
						}
		| assignment_stmt EOL
						{
							$$ = new Statement();
							$$->type = Statement::types::ASSIGNMENT;
							// $$->as = &$1;
							DEBUG("[Stmt:AssignStmt]");
						}
		| selection_stmt EOL
						{
							$$ = new Statement();
							$$->type = Statement::types::SELECTION;
							$$->ss = $1;
							DEBUG("[Stmt:SelectionStmt]");
						}
		| iteration
						{
							$$ = new Statement();
							$$->type = Statement::types::ITERATION;
							$$->is = $1;
							DEBUG("[Stmt:IterationStmt]");
						}
		| jump_stmt EOL
						{
							$$ = new Statement();
							$$->type = Statement::types::JUMP;
							$$->js = $1;
							DEBUG("[Stmt:JumpStmt]");
						}
		| defer_stmt EOL
						{
							$$ = new Statement();
							$$->type = Statement::types::DEFER;
							$$->ds = $1;
							DEBUG("[Stmt:DeferStmt]");
						}
		| block EOL
						{
							$$ = new Statement();
							$$->type = Statement::types::BLOCK;
							// $$->ds = $1;
							DEBUG("[Stmt:BlockStmt]");
						}
		| label_stmt EOL
						{
							$$ = new Statement();
							$$->type = Statement::types::LABEL;
							DEBUG("[Stmt:LabelStmt]");
						}
		;

/******************************************************************************************/
/************************************** LITERAL *******************************************/
/******************************************************************************************/

literal
		: bool_lit
						{
							$$ = new Literal();
							$$->type = Literal::types::BOOL;
							$$->boolean = $1;
							DEBUG("[Literal::Boolean]");
						}
		| int_lit
						{
							$$ = new Literal();
							$$->type = Literal::types::INT;
							$$->integer = $1;
							DEBUG("[Literal::Integer]");
						}
		| float_lit
						{
							$$ = new Literal();
							$$->type = Literal::types::FLOAT;
							$$->floating = $1;
							DEBUG("[Literal::Float]");
						}
		| char_lit
						{
							$$ = new Literal();
							$$->type = Literal::types::CHAR;
							$$->character = $1;
							DEBUG("[Literal::Char]");
						}
		| str_lit
						{
							$$ = new Literal();
							$$->type = Literal::types::STRING;
							$$->string = $1;
							DEBUG("[Literal::String]");
						}
		| ptr_lit
						{
							$$ = new Literal();
							$$->type = Literal::types::POINTER;
							$$->pointer = $1;
							DEBUG("[Literal::Pointer]");
						}
		| composite_lit
						{
							$$ = new Literal();
							$$->type = Literal::types::COMPOSITE;
							$$->composite = $1;
							DEBUG("[Literal::Composite]");
						}
		;

bool_lit
		: TRUE
						{
							$$ = new BooleanLiteral();
							$$->type = BooleanLiteral::types::TRUE;
							DEBUG("[Literal::Boolean::True]");
						}
		| FALSE
						{
							$$ = new BooleanLiteral();
							$$->type = BooleanLiteral::types::FALSE;
							DEBUG("[Literal::Boolean::False]");
						}
		;

int_lit
		: BINARY_LIT
						{
							$$ = new IntegerLiteral();
							$$->type = IntegerLiteral::types::BINARY;

							std::string bin_str = $1;
							bin_str.erase(0, 2);

							int len = bin_str.length();
							if (len <= 8) {
								$$->reg_size = 8;
							} else if (len <= 16) {
								$$->reg_size = 16;
							} else if (len <= 32) {
								$$->reg_size = 32;
							} else if (len <= 64) {
								$$->reg_size = 64;
							} else {
								ERR("Size of binary number is too large");
							}

							$$->value = stol(bin_str, nullptr, 2);

							DEBUG("[Literal::Integer::Binary]");
						}
		| OCTAL_LIT
						{
							$$ = new IntegerLiteral();
							$$->type = IntegerLiteral::types::OCTAL;

							std::string oct_str = $1;
							oct_str.erase(0, 2);

							$$->reg_size = 64;

							$$->value = stol(oct_str, nullptr, 8);

							DEBUG("[Literal::Integer::Octal]");
						}
		| DECIMAL_LIT
						{
							$$ = new IntegerLiteral();
							$$->type = IntegerLiteral::types::DECIMAL;

							std::string dec_str = $1;

							$$->reg_size = 64;

							$$->value = stol(dec_str, nullptr, 10);

							DEBUG("[Literal::Integer::Decimal]");
						}
		| HEX_LIT
						{
							$$ = new IntegerLiteral();
							$$->type = IntegerLiteral::types::HEX;

							std::string hex_str = $1;
							hex_str.erase(0, 3);

							int len = hex_str.length();
							if (len <= 2) {
								$$->reg_size = 8;
							} else if (len <= 4) {
								$$->reg_size = 16;
							} else if (len <= 8) {
								$$->reg_size = 32;
							} else if (len <= 16) {
								$$->reg_size = 64;
							} else {
								ERR("Size of hex number is too large");
							}

							$$->value = stol(hex_str, nullptr, 16);

							DEBUG("[Literal::Integer::Hex]");
						}
		;

float_lit
		: FLOAT_LIT
						{
							$$ = new FloatLiteral();
							$$->value = stold($1);
							if ($$->value <= std::numeric_limits<float>::max()) {
								$$->reg_size = 32;
							} else if ($$->value <= std::numeric_limits<double>::max()) {
								$$->reg_size = 64;
							} else {
								$$->reg_size = 128;
								/* TODO */
							}
							DEBUG("[Literal::Float]");
						}
		;

char_lit
		: CHAR_LIT
						{
							$$ = new CharLiteral();
							DEBUG("[Literal::Char]");
						}
		;

str_lit
		: STR1_LITERAL
						{
							$$ = new StringLiteral();
							$$->type = StringLiteral::types::STR1;
							DEBUG("[Literal::String::Str1]");
						}
		| STR2_LITERAL
						{
							$$ = new StringLiteral();
							$$->type = StringLiteral::types::STR2;
							DEBUG("[Literal::String::Str2]");
						}
		| RSTR1_LITERAL
						{
							$$ = new StringLiteral();
							$$->type = StringLiteral::types::RSTR1;
							DEBUG("[Literal::String::RStr1]");
						}
		| RSTR2_LITERAL
						{
							$$ = new StringLiteral();
							$$->type = StringLiteral::types::RSTR2;
							DEBUG("[Literal::String::RStr2]");
						}
		| HSTR1_LITERAL
						{
							$$ = new StringLiteral();
							$$->type = StringLiteral::types::HSTR1;
							DEBUG("[Literal::String::HStr1]");
						}
		| HSTR2_LITERAL
						{
							$$ = new StringLiteral();
							$$->type = StringLiteral::types::HSTR2;
							DEBUG("[Literal::String::HStr2]");
						}
		| HRSTR1_LITERAL
						{
							$$ = new StringLiteral();
							$$->type = StringLiteral::types::HRSTR1;
							DEBUG("[Literal::String::HRStr1]");
						}
		| HRSTR2_LITERAL
						{
							$$ = new StringLiteral();
							$$->type = StringLiteral::types::HRSTR2;
							DEBUG("[Literal::String::HRStr2]");
						}
		;

ptr_lit
		: PTR_NULL
						{
							$$ = new PointerLiteral();
							DEBUG("[Literal::Pointer]");
						}
		;

composite_lit
		: '{' composite_lit_list '}'
						{
							/* For struct, union, arrays, etc */
							$$ = new CompositeLiteral();
							DEBUG("[Literal::Composite]");
						}
		;

composite_lit_list
		: composite_lit_element
						{
						}
		| composite_lit_list ',' composite_lit_element
						{
						}
		;

composite_lit_element
		: expression
						{
						}
		| IDENTIFIER ':' expression
						{
						}
		;


/******************************************************************************************/
/******************************* COMPOSITE TYPE DEFINITION ********************************/
/******************************************************************************************/

composite_type_defn
		: struct_defn
						{
							$$ = new CompositeTypeDefn();
							$$->type = CompositeTypeDefn::types::STRUCT;
							$$->s = $1;
							DEBUG("[CompositeTypeDefn::Struct]");
						}
		| union_defn
						{
							$$ = new CompositeTypeDefn();
							$$->type = CompositeTypeDefn::types::UNION;
							$$->u = $1;
							DEBUG("[CompositeTypeDefn::Union]");
						}
		| enum_defn
						{
							$$ = new CompositeTypeDefn();
							$$->type = CompositeTypeDefn::types::ENUM;
							$$->e = $1;
							DEBUG("[CompositeTypeDefn::Enum]");
						}
		;

struct_defn
		: STRUCT IDENTIFIER template '{' struct_union_fields '}' variable_ident_list
						{
							$$ = new StructDefn();
							// $$->ident = $2;
							// $$->f = $6;
							DEBUG("[StructDefn::Template]");
						}
		| STRUCT IDENTIFIER '{' struct_union_fields '}' variable_ident_list
						{
							$$ = new StructDefn();
							// $$->ident = $2;
							// $$->f = $5;
							DEBUG("[StructDefn]");
						}

		| STRUCT IDENTIFIER template '{' struct_union_fields '}'
						{
							$$ = new StructDefn();
							// $$->ident = "";
							// $$->f = $6;
							DEBUG("[StructDefn::Template]");
						}
		| STRUCT IDENTIFIER '{' struct_union_fields '}'
						{
							$$ = new StructDefn();
							// $$->ident = "";
							// $$->f = $5;
							DEBUG("[StructDefn]");
						}
		| STRUCT template '{' struct_union_fields '}' variable_ident_list
						{
							$$ = new StructDefn();
							// $$->ident = "";
							// $$->f = $5;
							DEBUG("[StructDefn::Template]");
						}
		| STRUCT '{' struct_union_fields '}' variable_ident_list
						{
							$$ = new StructDefn();
							// $$->ident = "";
							// $$->f = $4;
							DEBUG("[StructDefn]");
						}
		| STRUCT template '{' struct_union_fields '}'
						{
							$$ = new StructDefn();
							// This is useless
							// $$->ident = "";
							// $$->f = $4;
							DEBUG("[StructDefn::Template]");
						}
		| STRUCT '{' struct_union_fields '}'
						{
							$$ = new StructDefn();
							// This is useless
							// $$->ident = "";
							// $$->f = $3;
							DEBUG("[StructDefn]");
						}
		;

union_defn
		: UNION IDENTIFIER '{' struct_union_fields '}' variable_ident_list
						{
							$$ = new UnionDefn();
							$$->ident = $2;
							$$->f = $4;
							DEBUG("[UnionDefn]");
						}
		| UNION IDENTIFIER '{' struct_union_fields '}'
						{
							$$ = new UnionDefn();
							$$->ident = $2;
							$$->f = $4;
							DEBUG("[UnionDefn]");
						}
		| UNION '{' struct_union_fields '}' variable_ident_list
						{
							$$ = new UnionDefn();
							$$->ident = "";
							$$->f = $3;
							DEBUG("[UnionDefn]");
						}
		| UNION '{' struct_union_fields '}'
						{
							$$ = new UnionDefn();
							// This is useless
							// $$->ident = "";
							// $$->f = $3;
							DEBUG("[UnionDefn]");
						}
		;

enum_defn
		: ENUM IDENTIFIER '{' enum_fields '}' variable_ident_list
						{
							$$ = new EnumDefn();
							$$->ident = $2;
							$$->f = $4;
							DEBUG("[EnumDefn]");
						}
		| ENUM IDENTIFIER '{' enum_fields '}'
						{
							$$ = new EnumDefn();
							$$->ident = $2;
							$$->f = $4;
							DEBUG("[EnumDefn]");
						}
		| ENUM '{' enum_fields '}' variable_ident_list
						{
							$$ = new EnumDefn();
							$$->ident = "";
							$$->f = $3;
							DEBUG("[EnumDefn]");
						}
		| ENUM '{' enum_fields '}'
						{
							$$ = new EnumDefn();
							// This is useless
							// $$->ident = "";
							// $$->f = $3;
							DEBUG("[EnumDefn]");
						}
		;

struct_union_fields
		: %empty
						{
							/* empty */
						}
		| struct_union_fields struct_union_field
						{
							if (!$1) {
								$1 = new StructUnionFields();
							}
							$1->suf.push_back($2);
							$$ = $1;
							DEBUG("[StructUnionFields]");
						}
		;

struct_union_field
		: type IDENTIFIER EOL
						{
							$$ = new StructUnionField();
							$$->t = $1;
							$$->ident = $2;
							DEBUG("[StructUnionField]");
						}
		;

enum_fields
		: %empty
						{
							/* empty */
						}
		| enum_fields IDENTIFIER EOL
						{
							if (!$1) {
								$1 = new EnumFields();
							}
							$1->i.push_back($2);
							$$ = $1;
							DEBUG("[EnumFields]");
						}
		;

/******************************************************************************************/
/************************************** OPERATORS *****************************************/
/******************************************************************************************/

assign_op
		: EQUAL_TO
						{
							$$ = new AssignOp();
							$$->is_compound = false;
							DEBUG("[=]");
						}
		| PLUS_EQUAL_TO
						{
							$$ = new AssignOp();
							$$->is_compound = true;
							$$->type = AssignOp::types::PLUS_EQUAL_TO;
							DEBUG("[+=]");
						}
		| MINUS_EQUAL_TO
						{
							$$ = new AssignOp();
							$$->is_compound = true;
							$$->type = AssignOp::types::MINUS_EQUAL_TO;
							DEBUG("[-=]");
						}
		| MULTIPLY_EQUAL_TO
						{
							$$ = new AssignOp();
							$$->is_compound = true;
							$$->type = AssignOp::types::MULTIPLY_EQUAL_TO;
							DEBUG("[-=]");
						}
		| DIVIDE_EQUAL_TO
						{
							$$ = new AssignOp();
							$$->is_compound = true;
							$$->type = AssignOp::types::DIVIDE_EQUAL_TO;
							DEBUG("[/=]");
						}
		| MODULUS_EQUAL_TO
						{
							$$ = new AssignOp();
							$$->is_compound = true;
							$$->type = AssignOp::types::MODULUS_EQUAL_TO;
							DEBUG("[%%=]");
						}
		| RIGHT_SHIFT_EQUAL_TO
						{
							$$ = new AssignOp();
							$$->is_compound = true;
							$$->type = AssignOp::types::RIGHT_SHIFT_EQUAL_TO;
							DEBUG("[<<=]");
						}
		| LEFT_SHIFT_EQUAL_TO
						{
							$$ = new AssignOp();
							$$->is_compound = true;
							$$->type = AssignOp::types::LEFT_SHIFT_EQUAL_TO;
							DEBUG("[>>=]");
						}
		| RIGHT_SHIFT_US_EQUAL_TO
						{
							$$ = new AssignOp();
							$$->is_compound = true;
							$$->type = AssignOp::types::RIGHT_SHIFT_US_EQUAL_TO;
							DEBUG("[<<<=]");
						}
		| LEFT_SHIFT_US_EQUAL_TO
						{
							$$ = new AssignOp();
							$$->is_compound = true;
							$$->type = AssignOp::types::LEFT_SHIFT_US_EQUAL_TO;
							DEBUG("[>>>=]");
						}
		| LOGICAL_AND_EQUAL_TO
						{
							$$ = new AssignOp();
							$$->is_compound = true;
							$$->type = AssignOp::types::LOGICAL_AND_EQUAL_TO;
							DEBUG("[&&=]");
						}
		| LOGICAL_OR_EQUAL_TO
						{
							$$ = new AssignOp();
							$$->is_compound = true;
							$$->type = AssignOp::types::LOGICAL_OR_EQUAL_TO;
							DEBUG("[||=]");
						}
		;

/******************************************************************************************/
/******************************* ASSIGNMENT STATEMENT *************************************/
/******************************************************************************************/

assignment_stmt
		: l_value_list assign_op expression
						{
							$$ = new AssignmentStmt();
							$$->lvl = $1;
							$$->ao = $2;
							$$->e = $3;
							DEBUG("[AssignmentStmt]");
						}
		;

l_value_list
		: l_value_list ',' l_value
						{
							$1->lvl.push_back($3);
							$$ = $1;
							DEBUG("[LValueList]");
						}
		| l_value
						{
							$$ = new LValueList();
							$$->lvl.push_back($1);
							DEBUG("[LValue]");
						}
		;

l_value
		: postfix_expr
						{
							$$ = new LValue();
							// $$->type = LValue::types::POSTFIX_EXPR;
							// $$->qi = $1;
							DEBUG("[LValue::QualifiedIdent]");
						}
		| U_POINTER expression
						{
							$$ = new LValue();
							// $$->type = LValue::types::PTR_TO_UNARY_EXP;
							// $$->ue = $2;
							DEBUG("[LValue::PtrToUnaryExpr]");
						}
		| '_'
						{
							$$ = new LValue();
							DEBUG("[LValue::_]");
						}
		;

expression
		: unary_expr
						{
							$$ = new Expression();
							$$->type = Expression::types::UNARY;
							$$->ue = $1;
							DEBUG("[UnaryExpr]");
						}
		| binary_expr
						{
							$$ = new Expression();
							$$->type = Expression::types::BINARY;
							$$->be = $1;
							DEBUG("[BinaryExpr]");
						}
		| '(' expression ')'
						{
							$$ = new Expression();
							DEBUG("[()Expr]");
						}
		;

binary_expr
		: expression PLUS expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::PLUS;
							$$->le = $1;
							$$->re = $3;
							DEBUG("[BinaryExpr::+]");
						}
		| expression MINUS expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::MINUS;
							$$->le = $1;
							$$->re = $3;
							DEBUG("[BinaryExpr::-]");
						}
		| expression MULTIPLY_OR_DEREF expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::MULTIPLY_OR_DEREF;
							$$->le = $1;
							$$->re = $3;
							DEBUG("[BinaryExpr::*]");
						}
		| expression DIVIDE expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::DIVIDE;
							$$->le = $1;
							$$->re = $3;
							DEBUG("[BinaryExpr::/]");
						}
		| expression MODULUS expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::MODULUS;
							$$->le = $1;
							$$->re = $3;
							DEBUG("[BinaryExpr::%%]");
						}
		| expression RIGHT_SHIFT expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::RIGHT_SHIFT;
							$$->le = $1;
							$$->re = $3;
							DEBUG("[BinaryExpr::>>]");
						}
		| expression LEFT_SHIFT expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::LEFT_SHIFT;
							$$->le = $1;
							$$->re = $3;
							DEBUG("[BinaryExpr::<<]");
						}
		| expression RIGHT_SHIFT_US expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::RIGHT_SHIFT_US;
							$$->le = $1;
							$$->re = $3;
							DEBUG("[BinaryExpr::>>>]");
						}
		| expression LEFT_SHIFT_US expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::LEFT_SHIFT_US;
							$$->le = $1;
							$$->re = $3;
							DEBUG("[BinaryExpr::<<<]");
						}
		| expression LOGICAL_AND expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::LOGICAL_AND;
							$$->le = $1;
							$$->re = $3;
							DEBUG("[BinaryExpr::&]");
						}
		| expression LOGICAL_OR expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::LOGICAL_OR;
							$$->le = $1;
							$$->re = $3;
							DEBUG("[BinaryExpr::|]");
						}
		| expression IS_EQUAL expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::IS_EQUAL;
							$$->le = $1;
							$$->re = $3;
							DEBUG("[BinaryExpr::==]");
						}
		| expression IS_NOT_EQUAL expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::IS_NOT_EQUAL;
							$$->le = $1;
							$$->re = $3;
							DEBUG("[BinaryExpr::!=]");
						}
		| expression IS_LESS expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::IS_LESS;
							$$->le = $1;
							$$->re = $3;
							DEBUG("[BinaryExpr::<]");
						}
		| expression IS_GREATER expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::IS_GREATER;
							$$->le = $1;
							$$->re = $3;
							DEBUG("[BinaryExpr::>]");
						}
		| expression IS_LESS_OR_EQ expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::IS_LESS_OR_EQ;
							$$->le = $1;
							$$->re = $3;
							DEBUG("[BinaryExpr::<=]");
						}
		| expression IS_GREATER_OR_EQ expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::IS_GREATER_OR_EQ;
							$$->le = $1;
							$$->re = $3;
							DEBUG("[BinaryExpr::>=]");
						}
		| expression BITWISE_AND expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::BITWISE_AND;
							$$->le = $1;
							$$->re = $3;
							DEBUG("[BinaryExpr::&&]");
						}
		| expression BITWISE_OR expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::BITWISE_OR;
							$$->le = $1;
							$$->re = $3;
							DEBUG("[BinaryExpr::||]");
						}
		| expression BITWISE_NOT expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::BITWISE_NOT;
							$$->le = $1;
							$$->re = $3;
							DEBUG("[BinaryExpr::^]");
						}
		| expression BITWISE_XOR expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::BITWISE_XOR;
							$$->le = $1;
							$$->re = $3;
							DEBUG("[BinaryExpr::&^]");
						}
		;

unary_expr
		: U_NOT expression
						{
							$$ = new UnaryExpression();
							$$->type = UnaryExpression::types::U_NOT;
							//$$->ue = $2;
							DEBUG("[UnaryExpr::!]");
						}
		| U_2COMP expression
						{
							$$ = new UnaryExpression();
							$$->type = UnaryExpression::types::U_2COMP;
							//$$->ue = $2;
							DEBUG("[UnaryExpr::~]");
						}
		| U_ADD_OF expression
						{
							$$ = new UnaryExpression();
							$$->type = UnaryExpression::types::U_ADD_OF;
							//$$->ue = $2;
							DEBUG("[UnaryExpr::@]");
						}
		| MULTIPLY_OR_DEREF expression
						{
							$$ = new UnaryExpression();
							$$->type = UnaryExpression::types::MULTIPLY_OR_DEREF;
							//$$->ue = $2;
							DEBUG("[UnaryExpr::$]");
						}
		| PLUS expression
						{
							$$ = new UnaryExpression();
							$$->type = UnaryExpression::types::PLUS;
							//$$->ue = $2;
							DEBUG("[UnaryExpr::+a]");
						}
		| MINUS expression
						{
							$$ = new UnaryExpression();
							$$->type = UnaryExpression::types::MINUS;
							//$$->ue = $2;
							DEBUG("[UnaryExpr::-a]");
						}
		| postfix_expr
						{
							$$ = new UnaryExpression();
							//$$->type = UnaryExpression::types::BRACES;
							//$$->e = $2;
							DEBUG("[UnaryExpr::()]");
						}
		| '[' type_name ']' expression %prec "type_cast"
						{
							// There is a S-R conflict between (int)a + b hence
							// give [int]a higher priority usng %prec
							$$ = new UnaryExpression();
						}
		| literal
						{
							$$ = new UnaryExpression();
						}
		;

postfix_expr
		: namespace_ident
						{
						}
		| postfix_expr '[' expression ']'
						{
						}
		| postfix_expr func_call_op
						{
						}
		| postfix_expr '.' IDENTIFIER
						{
						}
		| postfix_expr PTR_MEMBER IDENTIFIER
						{
						}
		;

namespace_ident
		: IDENTIFIER
						{
							$$ = new NameSpaceIdent;
							$$->ident = $1;
							$$->is_dot_NameSpaceIdent = false;
							$$->is_ptr_NameSpaceIdent = false;
							DEBUG("[Identifier]");
						}
		| namespace_ident SCOPE_RESOLUTION IDENTIFIER
						{
							$$ = new NameSpaceIdent;
							$$->ident = $3;
							$$->is_dot_NameSpaceIdent = true;
							$$->is_ptr_NameSpaceIdent = false;
							$$->dot_NameSpaceIdent = $1;
							DEBUG("[Identifier::X::Y]");
						}
		;

func_call_op
		: '(' func_argument_list ')'
						{
							$$ = new FunctionCallOp;
							// $$->el = $2;
							DEBUG("[FunctionCallOp]");
						}
		| template '(' func_argument_list ')'
						{
							$$ = new FunctionCallOp;
							// $$->el = $2;
							DEBUG("[FunctionCallOp::Template]");
						}
		;

func_argument_list
		: %empty
						{
						}
		| func_argument_list ',' func_argument
						{
						}
		| func_argument
						{
						}
		;

func_argument
		: expression
						{
						}
		| IDENTIFIER EQUAL_TO expression
						{
						}
		;

/*********************************** TEMPLATES ********************************************/

template
		: TEMPLATE_START template_items TEMPLATE_END
						{
						}
		;

template_items
		: template_items ',' type
						{
						}
		| type
						{
						}
		;

/******************************************************************************************/
/************************************** STATEMENTS ****************************************/
/******************************************************************************************/

variable_def
		: type variable_ident_list
						{
							$$ = new VariableDef();
							//$$->type = $1;
							//$$->ident = $2;
							//$$->lit = NULL;
							DEBUG("[VariableDef]");
						}
		| AUTO variable_ident_list
						{
							$$ = new VariableDef();
							//$$->type = $1;
							//$$->ident = $2;
							//$$->lit = NULL;
							DEBUG("[AutoVariableDef]");
						}
		;

variable_ident_list
		: variable_ident_list ',' IDENTIFIER EQUAL_TO expression
						{
							DEBUG("[VariableDef::IdentifierEqLit]");
						}
		| variable_ident_list ',' IDENTIFIER
						{
							DEBUG("[VariableDef::Identifier]");
						}
		| IDENTIFIER EQUAL_TO expression
						{
							DEBUG("[VariableDef::IdentifierEqLit]");
						}
		| IDENTIFIER
						{
							DEBUG("[VariableDef::Identifier]");
						}
		;

type_alias
		: TYPE IDENTIFIER EQUAL_TO type_name
						{
							DEBUG("[TypeAlias]");
						}

func_call_stmt
		: postfix_expr func_call_op
						{
							DEBUG("[FunctionCall]");
						}
		;

iteration
		: for_stmt EOL
						{
							$$ = new IterationStmt();
							$$->type = IterationStmt::types::FOR;
							$$->f = $1;
							DEBUG("[Iteration::ForStmt]");
						}
		| while_stmt EOL
						{
							$$ = new IterationStmt();
							$$->type = IterationStmt::types::WHILE;
							$$->w = $1;
							DEBUG("[Iteration::WhileStmt]");
						}
		| dowhile_stmt
						{
							$$ = new IterationStmt();
							$$->type = IterationStmt::types::DO_WHILE;
							$$->dw = $1;
							DEBUG("[Iteration::DoWhileStmt]");
						}
		| foreach_stmt
						{
							$$ = new IterationStmt();
							$$->type = IterationStmt::types::FOREACH;
							// $$->fe = $1;
							DEBUG("[Iteration::ForEach]");
						}
		;

for_stmt
		: FOR '(' for_init ';' for_cond ';' for_post ')' block
						{
							$$ = new ForStmt();
							$$->i = $3;
							$$->c = $5;
							$$->p = $7;
							DEBUG("[ForStmt]");
						}
		;

for_init
		: %empty
						{
							$$ = new ForInit();
							$$->is_set = false;
							DEBUG("[ForStmt::Init]");
						}
		| assignment_stmt
						{
							$$ = new ForInit();
							DEBUG("[ForStmt::Init]");
						}
		| variable_def
						{
							$$ = new ForInit();
							DEBUG("[ForStmt::Init]");
						}
		;

for_cond
		: %empty
						{
							$$ = new ForCondition();
							$$->is_set = false;
							DEBUG("[ForStmt::Condition]");
						}
		| expression
						{
							$$ = new ForCondition();
							$$->is_set = true;
							$$->e = $1;
							DEBUG("[ForStmt::Condition]");
						}
		;

for_post
		: %empty
						{
							$$ = new ForPost();
							$$->is_set = false;
							DEBUG("[ForStmt::Post]");
						}
		| assignment_stmt
						{
							$$ = new ForPost();
							DEBUG("[ForStmt::Post]");
						}
		| variable_def
						{
							$$ = new ForPost();
							DEBUG("[ForStmt::Post]");
						}
		;

foreach_stmt
		: FOREACH '(' foreach_expr ',' foreach_expr IN IDENTIFIER ')'
						{
						}
		| FOREACH '(' foreach_expr IN IDENTIFIER ')'
						{
						}
		;

foreach_expr
		: type IDENTIFIER
						{
						}
		| AUTO IDENTIFIER
						{
						}
		| IDENTIFIER
						{
						}
		;

while_stmt
		: WHILE '(' expression ')' block
						{
							$$ = new WhileStmt();
							$$->e = $3;
							$$->b = $5;
							DEBUG("[WhileStmt]");
						}
		;

dowhile_stmt
		: DO block WHILE '(' expression ')'
						{
							$$ = new DoWhileStmt();
							$$->b = $2;
							$$->e = $5;
							DEBUG("[DoWhileStmt]");
						}
		;

defer_stmt
		: DEFER block
						{
							$$ = new DeferStmt();
							$$->b = $2;
							DEBUG("[Defer]");
						}
		;

label_stmt
		: IDENTIFIER ':'
						{

						}
		;

selection_stmt
		: if_else_stmt
						{
							$$ = new SelectionStmt();
							$$->type = SelectionStmt::types::IF_ELSE;
							$$->ies = $1;
							DEBUG("[SelectionStmt::IfElseStmt]");
						}
		| switch_stmt
						{
							$$ = new SelectionStmt();
							$$->type = SelectionStmt::types::SWITCH;
							$$->ss = $1;
							DEBUG("[SelectionStmt::SwitchStmt]");
						}
		;

if_else_stmt
		: if_block
						{
							$$ = new IfElseStmt();
							$$->if_block = $1;
							$$->else_block = NULL;
							DEBUG("[IfElseStmt::If]");
						}
		| if_block else_block
						{
							$$ = new IfElseStmt();
							$$->if_block = $1;
							$$->else_block = $2;
							DEBUG("[IfElseStmt::IfElse]");
						}
		;

if_block
		: IF '(' expression ')' block
						{
							$$ = new IfBlock();
							$$->e = $3;
							$$->b = $5;
							DEBUG("[IfElseStmt::IfBlock]");
						}
		;

else_block
		: ELSE if_else_stmt
						{
							$$ = new ElseBlock();
							$$->is_set_if_else = true;
							$$->if_else = $2;
							$$->b = NULL;
							DEBUG("[IfElseStmt::ElseIfBlock]");

						}
		| ELSE block
						{
							$$ = new ElseBlock();
							$$->is_set_if_else = false;
							$$->if_else = NULL;
							$$->b = $2;
							DEBUG("[IfElseStmt::ElseBlock]");
						}
		;

switch_stmt
		: SWITCH '(' expression ')' '{' case_blocks '}'
						{
							$$ = new SwitchStmt();
							//$$->e = $3;
							//$$->c = $6;
							//$$->is_set_default = false;
							DEBUG("[SwitchStmt::SwitchCase]");
						}
		| SWITCH  '{' case_blocks '}'
						{
							$$ = new SwitchStmt();
							DEBUG("[SwitchStmt::SwitchCaseDefault]");
						}
		;

case_blocks
		: %empty
						{
						}
		| case_blocks case_block EOL
						{
						}
		;

case_block
		: CASE '(' case_expression_list ')' block
						{
							$$ = new CaseBlock();
							//$$->is_set = true;
							//CaseExpressionStmt *ce = new CaseExpressionStmt();
							//ce->e = $2;
							//ce->s = $4;
							//$$->case_expression_stmt.push_back(ce);
							DEBUG("[CaseBlock]");
						}
		| DEFAULT block
						{
							$$ = new CaseBlock();
							DEBUG("[CaseBlock]");
						}
		;

case_expression_list
		: case_expression_list ',' expression
						{
						}
		| expression
						{
						}
		;

jump_stmt
		: GOTO IDENTIFIER
						{
							$$ = new JumpStmt();
							$$->type = JumpStmt::types::GOTO;
							$$->goto_ident = $2;
							DEBUG("[Goto]");
						}
		| CONTINUE
						{
							$$ = new JumpStmt();
							$$->type = JumpStmt::types::CONTINUE;
							DEBUG("[Continue]");
						}
		| BREAK
						{
							$$ = new JumpStmt();
							$$->type = JumpStmt::types::BREAK;
							DEBUG("[Break]");
						}
		| RETURN return_argument_list
						{
							$$ = new JumpStmt();
							$$->type = JumpStmt::types::RETURN;
							DEBUG("[Return]");
						}
		;

return_argument_list
		: %empty
						{
							/* empty */
						}
		| return_argument_list ',' expression
						{
							//$1->el.push_back($3);
							//$$ = $1;
							DEBUG("[ExpressionList]");
						}
		| expression
						{
							//$$ = new ExpressionList;
							//$$->is_set = true;
							//$$->el.push_back($1);
							DEBUG("[ExpressionList]");
						}
		;

%%

int main() {
	// std::map<std::string, llvm::Value *> NamedValues; // Contains values defined in current scope

	// Make the module, which holds all the code.
	Module = std::make_unique<llvm::Module>("carbon module", Context);

	yy::Lexer lexer(std::cin);
	yy::parser parser(lexer);
	parser.parse();

	sf.codeGen();

	Module->print(llvm::errs(), nullptr);
	return 0;
}

void yy::parser::error(const location_type& loc, const std::string& msg) {
	std::cerr << "\033[31m" << msg << " @ " << "line=" << loc.begin.line
		<< " col=" << loc.begin.column << "\033[0m\n" << std::endl;
}
