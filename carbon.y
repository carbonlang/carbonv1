/*
Copyright (C) 2020 Prashant Shah <pshah.crb@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

%require  "3.0"
%skeleton "lalr1.cc"

%code requires {
	#include "ast.h"
	namespace yy {
		class Lexer;  // Generated by reflex with namespace=yy lexer=Lexer lex=yylex
	}
}

%defines
%locations
%parse-param { yy::Lexer& lexer }  // Construct parser object with lexer
%define api.value.type variant

%code {
	#include <typeinfo>
	#include <limits>
	#include "ast.h"
	#include "lex.yy.h"  // header file generated with reflex --header-file
	#undef yylex
	#define yylex lexer.yylex  // Within bison's parse() we should invoke lexer.yylex(), not the global yylex()

	// #define DEBUG(str) std::cout << str << "\n"
	#define DEBUG(str)
	#define ERR(str) std::cout << "\033[49;31m" \
		<< "**********************************************" << "\n" \
		<< str << "\n" \
		<< "**********************************************" << "\033[0m\n"
	#define ALERT(str) std::cout << "\033[49;32m" \
		<< "**********************************************" << "\n" \
		<< str << "\n" \
		<< "**********************************************" << "\033[0m\n"

	SourceFile sf;

	// LLVMContext owns a lot of core LLVM data structures, such as the type and constant value tables.
	llvm::LLVMContext Context;
	// IRBuilder is a helper to generate LLVM instructions
	llvm::IRBuilder<> Builder(Context);
	// Top level structure that contains functions and global variables
	std::unique_ptr<llvm::Module> Module;
	// Basic block
	llvm::BasicBlock *BB;
}

%token <int> NAMESAPCE
%token <int> IMPORT FROM AS
%token <std::string> STR_LITERAL WSTR_LITERAL U8STR_LITERAL U16STR_LITERAL U32STR_LITERAL
%token <std::string> RSTR_LITERAL
%token <int> ARROW
%token <std::string> IDENTIFIER
%token <int> DEF
%token <int> BOOL CHAR BYTE
%token <int> INT INT8 INT16 INT32 INT64 UINT UINT8 UINT16 UINT32 UINT64
%token <int> FLOAT32 FLOAT64 FLOAT128
%token <int> STRING
%token <int> POINTER
%token <int> GENERIC_POINTER
%token <int> AUTO
%token <int> TYPE
%token <int> STRUCT UNION ENUM
%token <int> EXTEND
%token <int> TRUE FALSE
%token <int> PTR_NULL
%token <int> REGISTER STATIC
%token <int> CONST VOLATILE RESTRICT ATOMIC CONST_RESTRICT
%token <std::string> BINARY_LIT OCTAL_LIT DECIMAL_LIT HEX_LIT
%token <std::string> FLOAT_LIT CHAR_LIT

%token <int> EQUAL_TO
%token <int> PLUS MINUS STAR DIVIDE MODULUS
%token <int> RIGHT_SHIFT LEFT_SHIFT RIGHT_SHIFT_US LEFT_SHIFT_US
%token <int> IS_EQUAL IS_NOT_EQUAL IS_LESS IS_GREATER IS_LESS_OR_EQ IS_GREATER_OR_EQ
%token <int> LOGICAL_OR LOGICAL_AND
%token <int> BITWISE_AND BITWISE_OR BITWISE_XOR BITWISE_AND_NOT

%token <int> PLUS_EQUAL_TO MINUS_EQUAL_TO STAR_EQUAL_TO DIVIDE_EQUAL_TO MODULUS_EQUAL_TO
%token <int> RIGHT_SHIFT_EQUAL_TO LEFT_SHIFT_EQUAL_TO RIGHT_SHIFT_US_EQUAL_TO LEFT_SHIFT_US_EQUAL_TO
%token <int> LOGICAL_OR_EQUAL_TO LOGICAL_AND_EQUAL_TO

%token <int> RETURN BREAK CONTINUE GOTO
%token <int> FOR WHILE DO FOREACH IN
%token <int> IF ELSE SWITCH CASE DEFAULT
%token <int> DEFER

%token <int> PUBLIC PRIVATE

%token <int> U_POINTER
%token <int> SCOPE_RESOLUTION

%token <int> TEMPLATE_START TEMPLATE_END

%token <int> EOL

%left PLUS MINUS STAR DIVIDE MODULUS
%left RIGHT_SHIFT LEFT_SHIFT RIGHT_SHIFT_US LEFT_SHIFT_US
%left IS_EQUAL IS_NOT_EQUAL IS_LESS IS_GREATER IS_LESS_OR_EQ IS_GREATER_OR_EQ
%left LOGICAL_OR LOGICAL_AND
%left BITWISE_AND BITWISE_OR BITWISE_XOR BITWISE_AND_NOT
%precedence U_NOT
%precedence U_COMPLEMENT
%precedence U_ADD_OF

%precedence "type_cast"

%nterm <int> source_file
%nterm <TopLevel *> top_level
%nterm <ImportDecl *> import_decl
%nterm <VariableDef *> variable_def
%nterm <VarIdentExpList *> variable_ident_list
%nterm <TypeAlias *> type_alias
%nterm <TypeFunction *> type_func
%nterm <CompositeTypeDefn *> composite_type_defn
%nterm <NamespaceDefn *> namespace_defn
%nterm <FunctionDefn *> func_defn

%nterm <AccessModifier *> access_modifier
%nterm <NamespaceBlockList *> namespace_block_list
%nterm <NamespaceBlock *> namespace_block

%nterm <FunctionDefnList *> func_defn_list

%nterm <Storage *> storage_class
%nterm <TypeQualifier *> type_qualifier
%nterm <TypeName *> type_name
%nterm <Type *> type
%nterm <Block *> block

%nterm <Statements *> statements
%nterm <Statement *> statement
%nterm <IterationStmt *> iteration
%nterm <ForStmt *> for_stmt
%nterm <ForInit *> for_init
%nterm <ForCondition *> for_cond
%nterm <ForPost *> for_post
%nterm <WhileStmt *> while_stmt
%nterm <DoWhileStmt *> dowhile_stmt
%nterm <DeferStmt *> defer_stmt

%nterm <Literal *> literal
%nterm <BooleanLiteral *> bool_lit
%nterm <IntegerLiteral *> int_lit
%nterm <FloatLiteral *> float_lit
%nterm <CharLiteral *> char_lit
%nterm <StringLiteral *> str_lit
%nterm <PointerLiteral * > ptr_lit
%nterm <CompositeLiteral *> composite_lit
%nterm <CompositeLiteralItemList *> composite_lit_item_list
%nterm <CompositeLiteralItem *> composite_lit_item
%nterm <StructDefn *> struct_defn
%nterm <UnionDefn *> union_defn
%nterm <EnumDefn *> enum_defn
%nterm <StructUnionFields *> struct_union_fields
%nterm <EnumFields *> enum_fields
%nterm <TypeIdentifier *> type_identifier
%nterm <FunctionSign *> func_sign
%nterm <FunctionParam *> func_param
%nterm <FunctionReturn *> func_return

%nterm <SelectionStmt *> selection_stmt
%nterm <IfElseStmt *> if_else_stmt
%nterm <SwitchStmt *> switch_stmt
%nterm <IfBlock *> if_block
%nterm <ElseBlock *> else_block
%nterm <CaseBlocks *> case_blocks
%nterm <CaseBlock *> case_block
%nterm <CaseExpressionList *> case_expression_list

%nterm <AssignOp *> assign_op
%nterm <LValue *> l_value
%nterm <Expression *> expression
%nterm <LValueList *> l_value_list
%nterm <ExpressionList *> expression_list
%nterm <FunctionCallStmt *> func_call_stmt
%nterm <AssignmentStmt *> assignment_stmt
%nterm <UnaryExpression *> unary_expr
%nterm <BinaryExpression *> binary_expr
%nterm <PostfixExpression *> postfix_expr
%nterm <IdentWithNamespace *> ident_with_ns
%nterm <FunctionCallOp *> func_call_op
%nterm <FunctionArgumentList *> func_argument_list
%nterm <FunctionArgument *> func_argument

%nterm <JumpStmt *> jump_stmt
%nterm <LabelStmt *> label_stmt
%nterm <ReturnExpr *> return_expr

%start source_file

%%

source_file
		: source_file top_level
						{
							sf.t.push_back($2);
							DEBUG("[SourceFile]");
						}
		| top_level
						{
							sf.t.push_back($1);
							DEBUG("[SourceFile]");
						}
		;

top_level
		: import_decl EOL
						{
							$$ = new TopLevel();
							$$->type = TopLevel::types::IMPORT_DECL;
							$$->id = $1;
							DEBUG("[TopLevel::ImportDecl]");
						}
		| variable_def EOL
						{
							$$ = new TopLevel();
							$$->type = TopLevel::types::VARIABLE_DEF;
							$$->vd = $1;
							$$->vd->is_global = true;
							DEBUG("[TopLevel::VariableDef]");
						}
		| composite_type_defn EOL
						{
							$$ = new TopLevel();
							$$->type = TopLevel::types::COMPOSITE_TYPE_DEFN;
							$$->ctd = $1;
							$$->ctd->is_global = true;
							DEBUG("[TopLevel::CompositeTypeDefn]");
						}
		| type_alias EOL
						{
							$$ = new TopLevel();
							$$->type = TopLevel::types::TYPE_ALIAS;
							$$->ta = $1;
							DEBUG("[TopLevel::TypeAlias]");
						}
		| type_func EOL
						{
							$$ = new TopLevel();
							$$->type = TopLevel::types::TYPE_FUNC;
							$$->tf = $1;
							DEBUG("[TopLevel::TypeFunction]");
						}
		| namespace_defn EOL
						{
							$$ = new TopLevel();
							$$->type = TopLevel::types::NAMESPACE_DEFN;
							$$->nsd = $1;
							DEBUG("[TopLevel::NamespaceDefn]");
						}
		| func_defn EOL
						{
							$$ = new TopLevel();
							$$->type = TopLevel::types::FUNC_DEFN;
							$$->fd = $1;
							DEBUG("[TopLevel::FunctionDefn]");
						}
		;

import_decl
		: IMPORT STR_LITERAL FROM STR_LITERAL AS STR_LITERAL
						{
							$$ = new ImportDecl();
							$$->import = $2;
							$$->from = $4;
							$$->as = $6;
							DEBUG("[ImportFromAs]");
						}
		| IMPORT STR_LITERAL FROM STR_LITERAL
						{
							$$ = new ImportDecl();
							$$->import = $2;
							$$->from = $4;
							DEBUG("[ImportFrom]");
						}
		| IMPORT STR_LITERAL
						{
							$$ = new ImportDecl();
							$$->import = $2;
							DEBUG("[Import]");
						}
		;

namespace_defn
		: NAMESAPCE IDENTIFIER '{' namespace_block_list '}'
						{
							$$ = new NamespaceDefn();
							$$->ident = $2;
							$$->nsbl = $4;
							DEBUG("[NS]");
						}
		;

namespace_block_list
		: %empty
						{
							/* Do nothing */
							DEBUG("[NS::BlockList]");
						}
		| namespace_block_list namespace_block
						{
							if (!$1) {
								$1 = new NamespaceBlockList();
							}
							$1->nsbl.push_back($2);
							$$ = $1;
							DEBUG("[NS::BlockList]");
						}
		;

namespace_block
		: variable_def EOL
						{
							$$ = new NamespaceBlock();
							$$->type = NamespaceBlock::types::VARIABLE_DEF;
							$$->vd = $1;
							$$->vd->is_global = true;
							DEBUG("[NS::VariableDef]");
						}
		| composite_type_defn EOL
						{
							$$ = new NamespaceBlock();
							$$->type = NamespaceBlock::types::COMPOSITE_TYPE_DEFN;
							$$->ctd = $1;
							$$->ctd->is_global = false;
							DEBUG("[NS::CompositeTypeDefn]");
						}
		| type_alias EOL
						{
							$$ = new NamespaceBlock();
							$$->type = NamespaceBlock::types::TYPE_ALIAS;
							// $$->ctd = $1;
							DEBUG("[NS::TypeAlias]");
						}
		| type_func EOL
						{
							$$ = new NamespaceBlock();
							$$->type = NamespaceBlock::types::TYPE_FUNC;
							$$->tf = $1;
							DEBUG("[NS::TypeFunction]");
						}
		| namespace_defn EOL
						{
							$$ = new NamespaceBlock();
							$$->type = NamespaceBlock::types::NAMESPACE_DEFN;
							$$->nd = $1;
							DEBUG("[NS::NamespaceDefn]");
						}
		| func_defn EOL
						{
							$$ = new NamespaceBlock();
							$$->type = NamespaceBlock::types::FUNC_DEFN;
							$$->fd = $1;
							DEBUG("[NS::FunctionDefn]");
						}
		;

func_defn
		: access_modifier DEF IDENTIFIER template func_sign block
						{
							$$ = new FunctionDefn();
							$$->am = $1;
							$$->ident = $3;
							$$->fs = $5;
							$$->b = $6;
							DEBUG("[FunctionDefn::Template]");
						}
		| access_modifier DEF IDENTIFIER func_sign block
						{
							$$ = new FunctionDefn();
							$$->am = $1;
							$$->ident = $3;
							$$->fs = $4;
							$$->b = $5;
							DEBUG("[FunctionDefn]");
						}
		;

access_modifier
		: %empty
						{
							/* Do nothing */
							DEBUG("[AccessModifier]");
						}
		| PUBLIC
						{
							$$ = new AccessModifier();
							$$->type = AccessModifier::types::PUBLIC;
							DEBUG("[AccessModifier]");
						}
		| PRIVATE
						{
							$$ = new AccessModifier();
							$$->type = AccessModifier::types::PRIVATE;
							DEBUG("[AccessModifier]");
						}
		;

func_sign
		: '(' func_param ')' ARROW '(' func_return ')'
						{
							$$ = new FunctionSign();
							$$->fp = $2;
							$$->fr = $6;
							DEBUG("[FuncSign]");
						}
		;

block
		: '{' statements '}'
						{
							$$ = new Block();
							$$->s = $2;
							DEBUG("[Block]");
						}
		;

func_param
		: %empty
						{
							/* Do nothing */
							DEBUG("[FunctionParam]");
						}
		| func_param ',' type_identifier
						{
							$1->fpl.push_back($3);
							$$ = $1;
							DEBUG("[FunctionParam]");
						}
		| type_identifier
						{
							$$ = new FunctionParam();
							$$->fpl.push_back($1);
							DEBUG("[FunctionParam]");
						}
		;

func_return
		: %empty
						{
							/* Do nothing */
							DEBUG("[FunctionReturn]");
						}
		| func_return ',' type_identifier
						{
							$1->frl.push_back($3);
							$$ = $1;
							DEBUG("[FunctionReturn]");
						}
		| func_return ',' type
						{
							TypeIdentifier *ti = new TypeIdentifier();
							ti->t = $3;
							ti->ident = "";
							$1->frl.push_back(ti);
							$$ = $1;
							DEBUG("[FunctionReturn]");
						}
		| type_identifier
						{
							$$ = new FunctionReturn();
							$$->frl.push_back($1);
							DEBUG("[FunctionReturn]");
						}
		| type
						{
							$$ = new FunctionReturn();
							TypeIdentifier *ti = new TypeIdentifier();
							ti->t = $1;
							ti->ident = "";
							$$->frl.push_back(ti);
							DEBUG("[FunctionReturn]");
						}
		;

type_identifier
		: type IDENTIFIER
						{
							$$ = new TypeIdentifier();
							$$->t = $1;
							$$->ident = $2;
							DEBUG("[TypeIdentifier]");
						}
		;

type_func
		: EXTEND type_name '{' func_defn_list '}'
						{
							$$ = new TypeFunction();
							$$->fdl = $4;
							DEBUG("[TypeFunction]");
						}
		;

func_defn_list
		: %empty
						{
							/* Do nothing */
							DEBUG("[TypeFunction::FunctionDefn]");
						}
		| func_defn_list func_defn EOL
						{
							if (!$1) {
								$1 = new FunctionDefnList();
								$1->is_set = true;
							}
							$1->fdl.push_back($2);
							$$ = $1;
							DEBUG("[TypeFunction::FunctionDefn]");
						}
		;

/******************************************************************************************/
/************************************** TYPES *********************************************/
/******************************************************************************************/

type
		: storage_class type_qualifier type_name
						{
							$$ = new Type();
							$$->storage = $1;
							$$->type_qualifier = $2;
							$$->type_name = $3;
							DEBUG("[Type->S::Q::T]");
						}
		| storage_class type_name
						{
							$$ = new Type();
							$$->storage = $1;
							$$->type_qualifier = NULL;
							$$->type_name = $2;
							DEBUG("[Type->S::T]");
						}
		| type_qualifier type_name
						{
							$$ = new Type();
							$$->storage = NULL;
							$$->type_qualifier = $1;
							$$->type_name = $2;
							DEBUG("[Type->Q::T]");
						}
		| type_name
						{
							$$ = new Type();
							$$->storage = NULL;
							$$->type_qualifier = NULL;
							$$->type_name = $1;
							DEBUG("[Type->T]");
						}
		;

storage_class
		: REGISTER
						{
							$$ = new Storage();
							$$->storage = Storage::storages::REGISTER;
							DEBUG("[Storage::Register]");
						}
		| STATIC
						{
							$$ = new Storage();
							$$->storage = Storage::storages::STATIC;
							DEBUG("[Storage::Static]");
						}
		;

type_qualifier
		: CONST
						{
							$$ = new TypeQualifier();
							$$->type_qualifier = TypeQualifier::type_qualifiers::CONST;
							DEBUG("[TypeQualifier::Const]");
						}
		| VOLATILE
						{
							$$ = new TypeQualifier();
							$$->type_qualifier = TypeQualifier::type_qualifiers::VOLATILE;
							DEBUG("[TypeQualifier::Volatile]");
						}
		| RESTRICT
						{
							$$ = new TypeQualifier();
							$$->type_qualifier = TypeQualifier::type_qualifiers::RESTRICT;
							DEBUG("[TypeQualifier::Restrict]");
						}
		| ATOMIC
						{
							$$ = new TypeQualifier();
							$$->type_qualifier = TypeQualifier::type_qualifiers::ATOMIC;
							DEBUG("[TypeQualifier::Atomic]");
						}
		| CONST_RESTRICT
						{
							$$ = new TypeQualifier();
							$$->type_qualifier = TypeQualifier::type_qualifiers::CONST_RESTRICT;
							DEBUG("[TypeQualifier::ConstRestrict]");
						}
		;

type_name
		: BOOL
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::BOOL;
							DEBUG("[Type::Bool]");
						}
		| CHAR
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::CHAR;
							DEBUG("[Type::Char]");
						}
		| BYTE
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::BYTE;
							DEBUG("[Type::Byte]");
						}
		| INT
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::INT;
							DEBUG("[Type::Int]");
						}
		| INT8
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::INT8;
							DEBUG("[Type::Int8]");
						}
		| INT16
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::INT16;
							DEBUG("[Type::Int16]");
						}
		| INT32
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::INT32;
							DEBUG("[Type::Int32]");
						}
		| INT64
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::INT64;
							DEBUG("[Type::Int64]");
						}
		| UINT
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::UINT;
							DEBUG("[Type::UInt]");
						}
		| UINT8
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::UINT8;
							DEBUG("[Type::UInt8]");
						}
		| UINT16
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::UINT16;
							DEBUG("[Type::UInt16]");
						}
		| UINT32
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::UINT32;
							DEBUG("[Type::UInt32]");
						}
		| UINT64
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::UINT64;
							DEBUG("[Type::UInt64]");
						}
		| FLOAT32
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::FLOAT32;
							DEBUG("[Type::Float32]");
						}
		| FLOAT64
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::FLOAT64;
							DEBUG("[Type::Float64]");
						}
		| FLOAT128
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::FLOAT128;
							DEBUG("[Type::Float128]");
						}
		| STRING
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::STRING;
							DEBUG("[Type::String]");
						}
		| POINTER ':' type_name
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::POINTER;
							DEBUG("[Type::Pointer]");
						}
		| GENERIC_POINTER
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::GENERIC_POINTER;
							DEBUG("[Type::GenericPointer]");
						}
		| STRUCT IDENTIFIER template
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::STRUCT_TEMPLATE;
							DEBUG("[Type::Struct::Template]");
						}
		| STRUCT IDENTIFIER
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::STRUCT;
							DEBUG("[Type::Struct]");
						}
		| UNION	IDENTIFIER template
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::UNION_TEMPLATE;
							DEBUG("[Type::Union::Template]");
						}
		| UNION	IDENTIFIER
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::UNION;
							DEBUG("[Type::Union]");
						}
		| ENUM IDENTIFIER
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::ENUM;
							DEBUG("[Type::ENUM]");
						}
		| function_type
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::FUNCTION;
							DEBUG("[Function]");
						}
		| IDENTIFIER
						{
							$$ = new TypeName();
							$$->type_name = TypeName::type_names::CUSTOM;
							DEBUG("[Type::CustomType]");
						}
		;

function_type
		: template '(' type_list ')' ARROW '(' type_list ')'
						{
						}
		| '(' type_list ')' ARROW '(' type_list ')'
						{
						}
		;

type_list
		: %empty
						{
							/* Do nothing */
							DEBUG("[TypeList]");
						}
		| type_list ',' type
						{
						}
		| type
						{
						}
		;


/******************************************************************************************/
/************************************** STATEMENTS ****************************************/
/******************************************************************************************/

statements
		: %empty
						{
							/* Do nothing */
							DEBUG("[Statements]");
						}
		| statements statement
						{
							if (!$1) {
								$1 = new Statements();
							}
							$1->s.push_back($2);
							$$ = $1;
							DEBUG("[Statements]");
						}
		;

statement
		: variable_def EOL
						{
							$$ = new Statement();
							$$->type = Statement::types::VARIABLE_DEF;
							$$->vds = $1;
							$$->vds->is_global = false;
							DEBUG("[Stmt:VariableDef]");
						}
		| composite_type_defn EOL
						{
							$$ = new Statement();
							$$->type = Statement::types::COMPOSITE_TYPE_DEFN;
							$$->ctd = $1;
							$$->ctd->is_global = false;
							DEBUG("[Stmt:CompositeTypeDefnStmt]");
						}
		| type_alias EOL
						{
							$$ = new Statement();
							$$->type = Statement::types::TYPE_ALIAS;
							// $$->ctd = $1;
							// $$->ctds->is_global = false;
							DEBUG("[Stmt::TypeAlias]");
						}
		| func_call_stmt EOL
						{
							$$ = new Statement();
							$$->type = Statement::types::FUNCTION_CALL;
							$$->fcs = $1;
							DEBUG("[Stmt:FunctionCallStmt]");
						}
		| assignment_stmt EOL
						{
							$$ = new Statement();
							$$->type = Statement::types::ASSIGNMENT;
							$$->as = $1;
							DEBUG("[Stmt:AssignStmt]");
						}
		| selection_stmt EOL
						{
							$$ = new Statement();
							$$->type = Statement::types::SELECTION;
							$$->ss = $1;
							DEBUG("[Stmt:SelectionStmt]");
						}
		| iteration
						{
							$$ = new Statement();
							$$->type = Statement::types::ITERATION;
							$$->is = $1;
							DEBUG("[Stmt:IterationStmt]");
						}
		| jump_stmt EOL
						{
							$$ = new Statement();
							$$->type = Statement::types::JUMP;
							$$->js = $1;
							DEBUG("[Stmt:JumpStmt]");
						}
		| defer_stmt EOL
						{
							$$ = new Statement();
							$$->type = Statement::types::DEFER;
							$$->ds = $1;
							DEBUG("[Stmt:DeferStmt]");
						}
		| block EOL
						{
							$$ = new Statement();
							$$->type = Statement::types::BLOCK;
							$$->b = $1;
							DEBUG("[Stmt:BlockStmt]");
						}
		| label_stmt EOL
						{
							$$ = new Statement();
							$$->type = Statement::types::LABEL;
							$$->ls = $1;
							DEBUG("[Stmt:LabelStmt]");
						}
		;

/******************************************************************************************/
/************************************** LITERAL *******************************************/
/******************************************************************************************/

literal
		: bool_lit
						{
							$$ = new Literal();
							$$->type = Literal::types::BOOL;
							$$->boolean_ptr = $1;
							DEBUG("[Literal::Boolean]");
						}
		| int_lit
						{
							$$ = new Literal();
							$$->type = Literal::types::INT;
							$$->integer_ptr = $1;
							DEBUG("[Literal::Integer]");
						}
		| float_lit
						{
							$$ = new Literal();
							$$->type = Literal::types::FLOAT;
							$$->floating_ptr = $1;
							DEBUG("[Literal::Float]");
						}
		| char_lit
						{
							$$ = new Literal();
							$$->type = Literal::types::CHAR;
							$$->character_ptr = $1;
							DEBUG("[Literal::Char]");
						}
		| str_lit
						{
							$$ = new Literal();
							$$->type = Literal::types::STRING;
							$$->string_ptr = $1;
							DEBUG("[Literal::String]");
						}
		| ptr_lit
						{
							$$ = new Literal();
							$$->type = Literal::types::POINTER;
							$$->pointer_ptr = $1;
							DEBUG("[Literal::Pointer]");
						}
		| composite_lit
						{
							$$ = new Literal();
							$$->type = Literal::types::COMPOSITE;
							$$->composite_ptr = $1;
							DEBUG("[Literal::Composite]");
						}
		;

bool_lit
		: TRUE
						{
							$$ = new BooleanLiteral();
							$$->type = BooleanLiteral::types::TRUE;
							DEBUG("[Literal::Boolean::True]");
						}
		| FALSE
						{
							$$ = new BooleanLiteral();
							$$->type = BooleanLiteral::types::FALSE;
							DEBUG("[Literal::Boolean::False]");
						}
		;

int_lit
		: BINARY_LIT
						{
							$$ = new IntegerLiteral();
							$$->type = IntegerLiteral::types::BINARY;

							std::string bin_str = $1;
							bin_str.erase(0, 2);

							int len = bin_str.length();
							if (len <= 8) {
								$$->reg_size = 8;
							} else if (len <= 16) {
								$$->reg_size = 16;
							} else if (len <= 32) {
								$$->reg_size = 32;
							} else if (len <= 64) {
								$$->reg_size = 64;
							} else {
								ERR("Size of binary number is too large");
							}

							$$->value = stol(bin_str, nullptr, 2);

							DEBUG("[Literal::Integer::Binary]");
						}
		| OCTAL_LIT
						{
							$$ = new IntegerLiteral();
							$$->type = IntegerLiteral::types::OCTAL;

							std::string oct_str = $1;
							oct_str.erase(0, 2);

							$$->reg_size = 64; /* TODO + NEG */

							$$->value = stol(oct_str, nullptr, 8);

							DEBUG("[Literal::Integer::Octal]");
						}
		| DECIMAL_LIT
						{
							$$ = new IntegerLiteral();
							$$->type = IntegerLiteral::types::DECIMAL;

							std::string dec_str = $1;

							$$->reg_size = 64; /* TODO */

							$$->value = stol(dec_str, nullptr, 10);

							DEBUG("[Literal::Integer::Decimal]");
						}
		| HEX_LIT
						{
							$$ = new IntegerLiteral();
							$$->type = IntegerLiteral::types::HEX;

							std::string hex_str = $1;
							hex_str.erase(0, 3);

							int len = hex_str.length();
							if (len <= 2) {
								$$->reg_size = 8;
							} else if (len <= 4) {
								$$->reg_size = 16;
							} else if (len <= 8) {
								$$->reg_size = 32;
							} else if (len <= 16) {
								$$->reg_size = 64;
							} else {
								ERR("Size of hex number is too large");
							}

							$$->value = stol(hex_str, nullptr, 16);

							DEBUG("[Literal::Integer::Hex]");
						}
		;

float_lit
		: FLOAT_LIT
						{
							$$ = new FloatLiteral();
							$$->value = stold($1);
							if ($$->value <= std::numeric_limits<float>::max()) {
								$$->reg_size = 32;
							} else if ($$->value <= std::numeric_limits<double>::max()) {
								$$->reg_size = 64;
							} else {
								$$->reg_size = 128;
								/* TODO */
							}
							DEBUG("[Literal::Float]");
						}
		;

char_lit
		: CHAR_LIT
						{
							$$ = new CharLiteral();
							int str_size = $1.size();
							if (str_size < 3) {
								ALERT("Invalid char literal");
							} else if (str_size > 4) {
								ALERT("Invalid char literal");
							} else if (str_size == 3) {
								$$->value = (int)$1.at(1);
							} else if (str_size == 4) {
								if ($1.at(1) != '\\') {
									ALERT("Invalid escape sequence");
								}
								switch ($1.at(2)) {
									// ASCII value of escape sequence
									case 'a' :
										$$->value = 7;
										break;
									case 'b' :
										$$->value = 8;
										break;
									case 'f' :
										$$->value = 12;
										break;
									case 'n' :
										$$->value = 10;
										break;
									case 'r' :
										$$->value = 13;
										break;
									case 't' :
										$$->value = 9;
										break;
									case 'v' :
										$$->value = 11;
										break;
									case '\'' :
										$$->value = 39;
										break;
									case '\"' :
										$$->value = 34;
										break;
									case '\?' :
										$$->value = 63;
										break;
									case '\\' :
										$$->value = 92;
										break;
									default :
										$$->value = 0;
										ALERT("Invalid escape sequence");
										break;

								}
							}
							DEBUG("[Literal::Char]");
						}
		;

str_lit
		: STR_LITERAL
						{
							$$ = new StringLiteral();
							$$->type = StringLiteral::types::STR_LITERAL;
							$$->string_literal = $1;
							DEBUG("[Literal::String::Str]");
						}
		| WSTR_LITERAL
						{
							$$ = new StringLiteral();
							$$->type = StringLiteral::types::WSTR_LITERAL;
							$$->string_literal = $1;
							DEBUG("[Literal::String::WStr]");
						}
		| U8STR_LITERAL
						{
							$$ = new StringLiteral();
							$$->type = StringLiteral::types::U8STR_LITERAL;
							$$->string_literal = $1;
							DEBUG("[Literal::String::U8Str]");
						}
		| U16STR_LITERAL
						{
							$$ = new StringLiteral();
							$$->type = StringLiteral::types::U16STR_LITERAL;
							$$->string_literal = $1;
							DEBUG("[Literal::String::U16Str]");
						}
		| U32STR_LITERAL
						{
							$$ = new StringLiteral();
							$$->type = StringLiteral::types::U32STR_LITERAL;
							$$->string_literal = $1;
							DEBUG("[Literal::String::U32Str]");
						}
		| RSTR_LITERAL
						{
							$$ = new StringLiteral();
							$$->type = StringLiteral::types::RSTR_LITERAL;
							$$->string_literal = $1;
							DEBUG("[Literal::String::RStr]");
						}
		;

ptr_lit
		: PTR_NULL
						{
							$$ = new PointerLiteral();
							DEBUG("[Literal::Pointer]");
						}
		;

composite_lit
		: '{' composite_lit_item_list '}'
						{
							/* For struct, union, arrays, etc */
							$$ = new CompositeLiteral();
							$$->composite_lit_item_list_ptr = $2;
							DEBUG("[Literal::Composite]");
						}
		;

composite_lit_item_list
		: composite_lit_item_list ',' composite_lit_item
						{
							$1->composite_lit_item_list.push_back($3);
							$$ = $1;
							DEBUG("[CompositeLitList]");
						}
		| composite_lit_item
						{
							$$ = new CompositeLiteralItemList();
							$$->composite_lit_item_list.push_back($1);
							DEBUG("[CompositeLitList]");
						}
		;

composite_lit_item
		: expression
						{
							$$ = new CompositeLiteralItem();
							$$->exp_ptr = $1;
							DEBUG("[CompositeLitListItem::Exp]");
						}
		| IDENTIFIER ':' expression
						{
							$$ = new CompositeLiteralItem();
							$$->ident = $1;
							$$->exp_ptr = $3;
							DEBUG("[CompositeLitListItem::IdentExp]");
						}
		;

/******************************************************************************************/
/******************************* COMPOSITE TYPE DEFINITION ********************************/
/******************************************************************************************/

composite_type_defn
		: struct_defn
						{
							$$ = new CompositeTypeDefn();
							$$->type = CompositeTypeDefn::types::STRUCT;
							$$->s = $1;
							DEBUG("[CompositeTypeDefn::Struct]");
						}
		| union_defn
						{
							$$ = new CompositeTypeDefn();
							$$->type = CompositeTypeDefn::types::UNION;
							$$->u = $1;
							DEBUG("[CompositeTypeDefn::Union]");
						}
		| enum_defn
						{
							$$ = new CompositeTypeDefn();
							$$->type = CompositeTypeDefn::types::ENUM;
							$$->e = $1;
							DEBUG("[CompositeTypeDefn::Enum]");
						}
		;

struct_defn
		: STRUCT IDENTIFIER template '{' struct_union_fields '}' variable_ident_list
						{
							$$ = new StructDefn();
							$$->ident = $2;
							$$->f = $5;
							DEBUG("[StructDefn::Template]");
						}
		| STRUCT IDENTIFIER '{' struct_union_fields '}' variable_ident_list
						{
							$$ = new StructDefn();
							$$->ident = $2;
							$$->f = $4;
							DEBUG("[StructDefn]");
						}

		| STRUCT IDENTIFIER template '{' struct_union_fields '}'
						{
							$$ = new StructDefn();
							$$->ident = $2;
							$$->f = $5;
							DEBUG("[StructDefn::Template]");
						}
		| STRUCT IDENTIFIER '{' struct_union_fields '}'
						{
							$$ = new StructDefn();
							$$->ident = $2;
							$$->f = $4;
							DEBUG("[StructDefn]");
						}
		| STRUCT template '{' struct_union_fields '}' variable_ident_list
						{
							$$ = new StructDefn();
							$$->ident = "";
							$$->f = $4;
							DEBUG("[StructDefn::Template]");
						}
		| STRUCT '{' struct_union_fields '}' variable_ident_list
						{
							$$ = new StructDefn();
							$$->ident = "";
							$$->f = $3;
							DEBUG("[StructDefn]");
						}
		| STRUCT template '{' struct_union_fields '}'
						{
							$$ = new StructDefn();
							// This is useless
							$$->ident = "";
							$$->f = $4;
							DEBUG("[StructDefn::Template]");
						}
		| STRUCT '{' struct_union_fields '}'
						{
							$$ = new StructDefn();
							// This is useless
							$$->ident = "";
							$$->f = $3;
							DEBUG("[StructDefn]");
						}
		;

union_defn
		: UNION IDENTIFIER '{' struct_union_fields '}' variable_ident_list
						{
							$$ = new UnionDefn();
							$$->ident = $2;
							$$->f = $4;
							DEBUG("[UnionDefn]");
						}
		| UNION IDENTIFIER '{' struct_union_fields '}'
						{
							$$ = new UnionDefn();
							$$->ident = $2;
							$$->f = $4;
							DEBUG("[UnionDefn]");
						}
		| UNION '{' struct_union_fields '}' variable_ident_list
						{
							$$ = new UnionDefn();
							$$->ident = "";
							$$->f = $3;
							DEBUG("[UnionDefn]");
						}
		| UNION '{' struct_union_fields '}'
						{
							$$ = new UnionDefn();
							// This is useless
							$$->ident = "";
							$$->f = $3;
							DEBUG("[UnionDefn]");
						}
		;

enum_defn
		: ENUM IDENTIFIER '{' enum_fields '}' variable_ident_list
						{
							$$ = new EnumDefn();
							$$->ident = $2;
							$$->f = $4;
							DEBUG("[EnumDefn]");
						}
		| ENUM IDENTIFIER '{' enum_fields '}'
						{
							$$ = new EnumDefn();
							$$->ident = $2;
							$$->f = $4;
							DEBUG("[EnumDefn]");
						}
		| ENUM '{' enum_fields '}' variable_ident_list
						{
							$$ = new EnumDefn();
							$$->ident = "";
							$$->f = $3;
							DEBUG("[EnumDefn]");
						}
		| ENUM '{' enum_fields '}'
						{
							$$ = new EnumDefn();
							// This is useless
							$$->ident = "";
							$$->f = $3;
							DEBUG("[EnumDefn]");
						}
		;

struct_union_fields
		: %empty
						{
							/* empty */
						}
		| struct_union_fields variable_def EOL
						{
							if (!$1) {
								$1 = new StructUnionFields();
							}
							$1->vdl.push_back($2);
							$$ = $1;
							DEBUG("[StructUnionFields]");
						}
		;

enum_fields
		: %empty
						{
							/* Do nothing */
							DEBUG("[EnumFields]");
						}
		| enum_fields IDENTIFIER EOL
						{
							if (!$1) {
								$1 = new EnumFields();
							}
							$1->i.push_back($2);
							$$ = $1;
							DEBUG("[EnumFields]");
						}
		;

/******************************************************************************************/
/************************************** OPERATORS *****************************************/
/******************************************************************************************/

assign_op
		: EQUAL_TO
						{
							$$ = new AssignOp();
							$$->is_compound = false;
							DEBUG("[=]");
						}
		| PLUS_EQUAL_TO
						{
							$$ = new AssignOp();
							$$->is_compound = true;
							$$->type = AssignOp::types::PLUS_EQUAL_TO;
							DEBUG("[+=]");
						}
		| MINUS_EQUAL_TO
						{
							$$ = new AssignOp();
							$$->is_compound = true;
							$$->type = AssignOp::types::MINUS_EQUAL_TO;
							DEBUG("[-=]");
						}
		| STAR_EQUAL_TO
						{
							$$ = new AssignOp();
							$$->is_compound = true;
							$$->type = AssignOp::types::STAR_EQUAL_TO;
							DEBUG("[-=]");
						}
		| DIVIDE_EQUAL_TO
						{
							$$ = new AssignOp();
							$$->is_compound = true;
							$$->type = AssignOp::types::DIVIDE_EQUAL_TO;
							DEBUG("[/=]");
						}
		| MODULUS_EQUAL_TO
						{
							$$ = new AssignOp();
							$$->is_compound = true;
							$$->type = AssignOp::types::MODULUS_EQUAL_TO;
							DEBUG("[%%=]");
						}
		| RIGHT_SHIFT_EQUAL_TO
						{
							$$ = new AssignOp();
							$$->is_compound = true;
							$$->type = AssignOp::types::RIGHT_SHIFT_EQUAL_TO;
							DEBUG("[<<=]");
						}
		| LEFT_SHIFT_EQUAL_TO
						{
							$$ = new AssignOp();
							$$->is_compound = true;
							$$->type = AssignOp::types::LEFT_SHIFT_EQUAL_TO;
							DEBUG("[>>=]");
						}
		| RIGHT_SHIFT_US_EQUAL_TO
						{
							$$ = new AssignOp();
							$$->is_compound = true;
							$$->type = AssignOp::types::RIGHT_SHIFT_US_EQUAL_TO;
							DEBUG("[<<<=]");
						}
		| LEFT_SHIFT_US_EQUAL_TO
						{
							$$ = new AssignOp();
							$$->is_compound = true;
							$$->type = AssignOp::types::LEFT_SHIFT_US_EQUAL_TO;
							DEBUG("[>>>=]");
						}
		| LOGICAL_AND_EQUAL_TO
						{
							$$ = new AssignOp();
							$$->is_compound = true;
							$$->type = AssignOp::types::LOGICAL_AND_EQUAL_TO;
							DEBUG("[&&=]");
						}
		| LOGICAL_OR_EQUAL_TO
						{
							$$ = new AssignOp();
							$$->is_compound = true;
							$$->type = AssignOp::types::LOGICAL_OR_EQUAL_TO;
							DEBUG("[||=]");
						}
		;

/******************************************************************************************/
/******************************* ASSIGNMENT STATEMENT *************************************/
/******************************************************************************************/

assignment_stmt
		: l_value_list assign_op expression_list
						{
							$$ = new AssignmentStmt();
							$$->l_value_list_ptr = $1;
							$$->ao = $2;
							$$->expr_list_ptr = $3;
							DEBUG("[AssignmentStmt]");
						}
		;

expression_list
		: expression_list ',' expression
						{
							$1->expr_list.push_back($3);
							$$ = $1;
							DEBUG("[Expression]");
						}
		| expression
						{
							$$ = new ExpressionList();
							$$->expr_list.push_back($1);
							DEBUG("[Expression]");
						}
		;

l_value_list
		: l_value_list ',' l_value
						{
							$1->l_value_list.push_back($3);
							$$ = $1;
							DEBUG("[LValueList]");
						}
		| l_value
						{
							$$ = new LValueList();
							$$->l_value_list.push_back($1);
							DEBUG("[LValue]");
						}
		;

l_value
		: postfix_expr
						{
							$$ = new LValue();
							$$->type = LValue::types::POSTFIX_EXPR;
							$$->postfix_expr_ptr = $1;
							DEBUG("[LValue::PostfixExpr]");
						}
		| U_POINTER expression
						{
							$$ = new LValue();
							$$->type = LValue::types::PTR_TO_EXP;
							$$->expr_ptr = $2;
							DEBUG("[LValue::PointerToExpr]");
						}
		| '_'
						{
							$$ = new LValue();
							$$->type = LValue::types::UNDERSCORE;
							DEBUG("[LValue::_]");
						}
		;

expression
		: unary_expr
						{
							$$ = new Expression();
							$$->type = Expression::types::UNARY;
							$$->unary_expr_ptr = $1;
							DEBUG("[UnaryExpr]");
						}
		| binary_expr
						{
							$$ = new Expression();
							$$->type = Expression::types::BINARY;
							$$->binary_expr_ptr = $1;
							DEBUG("[BinaryExpr]");
						}
		| '(' expression ')'
						{
							$$ = new Expression();
							$$->type = Expression::types::EXPRESSION;
							$$->expr_ptr = $2;
							DEBUG("[()Expr]");
						}
		;

binary_expr
		: expression PLUS expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::PLUS;
							$$->left_expr_ptr = $1;
							$$->right_expr_ptr = $3;
							DEBUG("[BinaryExpr::+]");
						}
		| expression MINUS expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::MINUS;
							$$->left_expr_ptr = $1;
							$$->right_expr_ptr = $3;
							DEBUG("[BinaryExpr::-]");
						}
		| expression STAR expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::STAR;
							$$->left_expr_ptr = $1;
							$$->right_expr_ptr = $3;
							DEBUG("[BinaryExpr::*]");
						}
		| expression DIVIDE expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::DIVIDE;
							$$->left_expr_ptr = $1;
							$$->right_expr_ptr = $3;
							DEBUG("[BinaryExpr::/]");
						}
		| expression MODULUS expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::MODULUS;
							$$->left_expr_ptr = $1;
							$$->right_expr_ptr = $3;
							DEBUG("[BinaryExpr::%%]");
						}
		| expression RIGHT_SHIFT expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::RIGHT_SHIFT;
							$$->left_expr_ptr = $1;
							$$->right_expr_ptr = $3;
							DEBUG("[BinaryExpr::>>]");
						}
		| expression LEFT_SHIFT expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::LEFT_SHIFT;
							$$->left_expr_ptr = $1;
							$$->right_expr_ptr = $3;
							DEBUG("[BinaryExpr::<<]");
						}
		| expression RIGHT_SHIFT_US expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::RIGHT_SHIFT_US;
							$$->left_expr_ptr = $1;
							$$->right_expr_ptr = $3;
							DEBUG("[BinaryExpr::>>>]");
						}
		| expression LEFT_SHIFT_US expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::LEFT_SHIFT_US;
							$$->left_expr_ptr = $1;
							$$->right_expr_ptr = $3;
							DEBUG("[BinaryExpr::<<<]");
						}
		| expression LOGICAL_AND expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::LOGICAL_AND;
							$$->left_expr_ptr = $1;
							$$->right_expr_ptr = $3;
							DEBUG("[BinaryExpr::&]");
						}
		| expression LOGICAL_OR expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::LOGICAL_OR;
							$$->left_expr_ptr = $1;
							$$->right_expr_ptr = $3;
							DEBUG("[BinaryExpr::|]");
						}
		| expression IS_EQUAL expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::IS_EQUAL;
							$$->left_expr_ptr = $1;
							$$->right_expr_ptr = $3;
							DEBUG("[BinaryExpr::==]");
						}
		| expression IS_NOT_EQUAL expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::IS_NOT_EQUAL;
							$$->left_expr_ptr = $1;
							$$->right_expr_ptr = $3;
							DEBUG("[BinaryExpr::!=]");
						}
		| expression IS_LESS expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::IS_LESS;
							$$->left_expr_ptr = $1;
							$$->right_expr_ptr = $3;
							DEBUG("[BinaryExpr::<]");
						}
		| expression IS_GREATER expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::IS_GREATER;
							$$->left_expr_ptr = $1;
							$$->right_expr_ptr = $3;
							DEBUG("[BinaryExpr::>]");
						}
		| expression IS_LESS_OR_EQ expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::IS_LESS_OR_EQ;
							$$->left_expr_ptr = $1;
							$$->right_expr_ptr = $3;
							DEBUG("[BinaryExpr::<=]");
						}
		| expression IS_GREATER_OR_EQ expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::IS_GREATER_OR_EQ;
							$$->left_expr_ptr = $1;
							$$->right_expr_ptr = $3;
							DEBUG("[BinaryExpr::>=]");
						}
		| expression BITWISE_AND expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::BITWISE_AND;
							$$->left_expr_ptr = $1;
							$$->right_expr_ptr = $3;
							DEBUG("[BinaryExpr::&&]");
						}
		| expression BITWISE_OR expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::BITWISE_OR;
							$$->left_expr_ptr = $1;
							$$->right_expr_ptr = $3;
							DEBUG("[BinaryExpr::||]");
						}
		| expression BITWISE_XOR expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::BITWISE_XOR;
							$$->left_expr_ptr = $1;
							$$->right_expr_ptr = $3;
							DEBUG("[BinaryExpr::^]");
						}
		| expression BITWISE_AND_NOT expression
						{
							$$ = new BinaryExpression();
							$$->type = BinaryExpression::types::BITWISE_AND_NOT;
							$$->left_expr_ptr = $1;
							$$->right_expr_ptr = $3;
							DEBUG("[BinaryExpr::&^]");
						}
		;

unary_expr
		: U_NOT expression
						{
							$$ = new UnaryExpression();
							$$->type = UnaryExpression::types::U_NOT;
							$$->expr_ptr = $2;
							DEBUG("[UnaryExpr::!]");
						}
		| U_COMPLEMENT expression
						{
							$$ = new UnaryExpression();
							$$->type = UnaryExpression::types::U_COMPLEMENT;
							$$->expr_ptr = $2;
							DEBUG("[UnaryExpr::~]");
						}
		| U_ADD_OF expression
						{
							$$ = new UnaryExpression();
							$$->type = UnaryExpression::types::U_ADD_OF;
							$$->expr_ptr = $2;
							DEBUG("[UnaryExpr::@]");
						}
		| STAR expression
						{
							$$ = new UnaryExpression();
							$$->type = UnaryExpression::types::STAR;
							$$->expr_ptr = $2;
							DEBUG("[UnaryExpr::$]");
						}
		| PLUS expression
						{
							$$ = new UnaryExpression();
							$$->type = UnaryExpression::types::PLUS;
							$$->expr_ptr = $2;
							DEBUG("[UnaryExpr::+a]");
						}
		| MINUS expression
						{
							$$ = new UnaryExpression();
							$$->type = UnaryExpression::types::MINUS;
							$$->expr_ptr = $2;
							DEBUG("[UnaryExpr::-a]");
						}
		| postfix_expr
						{
							$$ = new UnaryExpression();
							$$->type = UnaryExpression::types::POSTFIX_EXPR;
							$$->postfix_expr_ptr = $1;
							DEBUG("[UnaryExpr::PostfixExpr]");
						}
		| '[' type_name ']' expression		%prec "type_cast"
						{
							// Note : There is a S-R conflict between (int)a + b hence
							// give [int]a higher priority usng %prec
							$$ = new UnaryExpression();
							$$->type = UnaryExpression::types::TYPE_CAST;
							$$->expr_ptr = $4;
							DEBUG("[UnaryExpr::TypeCastExpr]");
						}
		| literal
						{
							$$ = new UnaryExpression();
							$$->type = UnaryExpression::types::LITERAL;
							$$->lit_ptr = $1;
							DEBUG("[UnaryExpr::LiteralExpr]");
						}
		;

postfix_expr
		: ident_with_ns
						{
							$$ = new PostfixExpression();
							$$->type = PostfixExpression::types::IDENT_WITH_NS;
							$$->ident_with_ns_ptr = $1;
							DEBUG("[PostfixExpr::IdentWithNS]");
						}
		| postfix_expr '[' expression ']'
						{
							$$ = new PostfixExpression();
							$$->type = PostfixExpression::types::ARRAY;
							$$->postfix_expr_ptr = $1;
							$$->array_expr_ptr = $3;
							DEBUG("[PostfixExpr::Array]");
						}
		| postfix_expr func_call_op
						{
							$$ = new PostfixExpression();
							$$->type = PostfixExpression::types::FUNCTION_CALL;
							$$->postfix_expr_ptr = $1;
							$$->func_call_op_ptr = $2;
							DEBUG("[PostfixExpr::FuncCall]");
						}
		| postfix_expr '.' IDENTIFIER
						{
							$$ = new PostfixExpression();
							$$->type = PostfixExpression::types::DOT_OP;
							$$->postfix_expr_ptr = $1;
							$$->dot_ident = $3;
							DEBUG("[PostfixExpr::DotIdent]");
						}
		| postfix_expr ARROW IDENTIFIER
						{
							$$ = new PostfixExpression();
							$$->type = PostfixExpression::types::ARROW_OP;
							$$->postfix_expr_ptr = $1;
							$$->arrow_ident = $3;
							DEBUG("[PostfixExpr::ArrowIdent]");
						}
		;

ident_with_ns
		: ident_with_ns SCOPE_RESOLUTION IDENTIFIER
						{
							$$ = $1;
							$$->ident = $$->ident + "::" + $3;
							DEBUG("[IdentWithNamespace::X::Y]");
						}
		| IDENTIFIER
						{
							$$ = new IdentWithNamespace;
							$$->ident = $1;
							DEBUG("[IdentWithNamespace]");
						}
		;

func_call_op
		: '(' func_argument_list ')'
						{
							$$ = new FunctionCallOp;
							$$->func_arg_list_ptr = $2;
							DEBUG("[FunctionCallOp]");
						}
		| template '(' func_argument_list ')'
						{
							$$ = new FunctionCallOp;
							$$->func_arg_list_ptr = $3;
							DEBUG("[FunctionCallOp::Template]");
						}
		;

func_argument_list
		: %empty
						{
							$$ = new FunctionArgumentList();
							$$->is_set = false;
							DEBUG("[FunctionArgumentNo]");
						}
		| func_argument_list ',' func_argument
						{
							$1->func_arg_list.push_back($3);
							$$ = $1;
							DEBUG("[FunctionArgument]");
						}
		| func_argument
						{
							$$ = new FunctionArgumentList();
							$$->is_set = true;
							$$->func_arg_list.push_back($1);
							DEBUG("[FunctionArgument]");
						}
		;

func_argument
		: expression
						{
							$$ = new FunctionArgument();
							$$->expr_ptr = $1;
							$$->is_ident = false;
							DEBUG("[FunctionArgument]");
						}
		| IDENTIFIER EQUAL_TO expression
						{
							$$ = new FunctionArgument();
							$$->expr_ptr = $3;
							$$->is_ident = true;
							$$->ident = $1;
							DEBUG("[FunctionArgumentWithIdent]");
						}
		;

/*********************************** TEMPLATES ********************************************/

template
		: TEMPLATE_START template_items TEMPLATE_END
						{
						}
		;

template_items
		: template_items ',' type
						{
						}
		| type
						{
						}
		;

/******************************************************************************************/
/************************************** STATEMENTS ****************************************/
/******************************************************************************************/

variable_def
		: type variable_ident_list
						{
							$$ = new VariableDef();
							std::list<VarIdentExp *>::iterator viei;
							for (viei = $2->viel.begin(); viei != $2->viel.end(); ++viei) {
								(*viei)->t = $1;
							}
							$$->v = $2;
							DEBUG("[VariableDef::Type]");
						}
		| AUTO variable_ident_list
						{
							$$ = new VariableDef();
							std::list<VarIdentExp *>::iterator viei;
							for (viei = $2->viel.begin(); viei != $2->viel.end(); ++viei) {
								(*viei)->t = new Type();
								(*viei)->t->type_name = new TypeName();
								(*viei)->t->type_name->type_name = TypeName::type_names::AUTO;
							}
							$$->v = $2;
							DEBUG("[VariableDef::Auto]");
						}
		;

variable_ident_list
		: variable_ident_list ',' IDENTIFIER EQUAL_TO expression
						{
							VarIdentExp *v = new VarIdentExp();
							v->ident = $3;
							v->t = NULL;
							v->e = $5;
							$1->viel.push_back(v);
							$$ = $1;
							DEBUG("[VariableDef::IdentifierEqExp]");
						}
		| variable_ident_list ',' IDENTIFIER
						{
							VarIdentExp *v = new VarIdentExp();
							v->ident = $3;
							v->t = NULL;
							v->e = NULL;
							$1->viel.push_back(v);
							$$ = $1;
							DEBUG("[VariableDef::Identifier]");
						}
		| IDENTIFIER EQUAL_TO expression
						{
							$$ = new VarIdentExpList();
							VarIdentExp *v = new VarIdentExp();
							v->ident = $1;
							v->t = NULL;
							v->e = $3;
							$$->viel.push_back(v);
							DEBUG("[VariableDef::IdentifierEqExp]");
						}
		| IDENTIFIER
						{
							$$ = new VarIdentExpList();
							VarIdentExp *v = new VarIdentExp();
							v->ident = $1;
							v->t = NULL;
							v->e = NULL;
							$$->viel.push_back(v);
							DEBUG("[VariableDef::Identifier]");
						}
		;

type_alias
		: TYPE IDENTIFIER EQUAL_TO type_name
						{
							$$ = new TypeAlias();
							DEBUG("[TypeAlias]");
						}

func_call_stmt
		: postfix_expr func_call_op
						{
							$$ = new FunctionCallStmt();
							$$->postfix_expr_ptr = $1;
							$$->func_call_op_ptr = $2;
							DEBUG("[FunctionCall]");
						}
		;

iteration
		: for_stmt EOL
						{
							$$ = new IterationStmt();
							$$->type = IterationStmt::types::FOR;
							$$->f = $1;
							DEBUG("[Iteration::ForStmt]");
						}
		| while_stmt EOL
						{
							$$ = new IterationStmt();
							$$->type = IterationStmt::types::WHILE;
							$$->w = $1;
							DEBUG("[Iteration::WhileStmt]");
						}
		| dowhile_stmt
						{
							$$ = new IterationStmt();
							$$->type = IterationStmt::types::DO_WHILE;
							$$->dw = $1;
							DEBUG("[Iteration::DoWhileStmt]");
						}
		| foreach_stmt
						{
							$$ = new IterationStmt();
							$$->type = IterationStmt::types::FOREACH;
							// $$->fe = $1;
							DEBUG("[Iteration::ForEach]");
						}
		;

for_stmt
		: FOR '(' for_init ';' for_cond ';' for_post ')' block
						{
							$$ = new ForStmt();
							$$->i = $3;
							$$->c = $5;
							$$->p = $7;
							$$->b = $9;
							DEBUG("[ForStmt]");
						}
		;

for_init
		: %empty
						{
							$$ = new ForInit();
							$$->is_set = false;
							DEBUG("[ForStmt::Init]");
						}
		| assignment_stmt
						{
							$$ = new ForInit();
							$$->is_set = true;
							$$->type = ForInit::types::ASSIGN_STMT;
							$$->assign_stmt_ptr = $1;
							DEBUG("[ForStmt::Init]");
						}
		| variable_def
						{
							$$ = new ForInit();
							$$->is_set = true;
							$$->type = ForInit::types::VARIABLE_DEF_STMT;
							$$->var_def_stmt_ptr = $1;
							DEBUG("[ForStmt::Init]");
						}
		;

for_cond
		: %empty
						{
							$$ = new ForCondition();
							$$->is_set = false;
							DEBUG("[ForStmt::Condition]");
						}
		| expression
						{
							$$ = new ForCondition();
							$$->is_set = true;
							$$->e = $1;
							DEBUG("[ForStmt::Condition]");
						}
		;

for_post
		: %empty
						{
							$$ = new ForPost();
							$$->is_set = false;
							DEBUG("[ForStmt::Post]");
						}
		| assignment_stmt
						{
							$$ = new ForPost();
							$$->is_set = true;
							$$->type = ForPost::types::ASSIGN_STMT;
							$$->assign_stmt_ptr = $1;
							DEBUG("[ForStmt::Post]");
						}
		;

foreach_stmt
		: FOREACH '(' foreach_expr ',' foreach_expr  ')' IN IDENTIFIER
						{
						}
		| FOREACH '(' foreach_expr  ')' IN IDENTIFIER
						{
						}
		;

foreach_expr
		: type IDENTIFIER
						{
						}
		| AUTO IDENTIFIER
						{
						}
		| IDENTIFIER
						{
						}
		;

while_stmt
		: WHILE '(' expression ')' block
						{
							$$ = new WhileStmt();
							$$->e = $3;
							$$->b = $5;
							DEBUG("[WhileStmt]");
						}
		;

dowhile_stmt
		: DO block WHILE '(' expression ')' EOL
						{
							$$ = new DoWhileStmt();
							$$->b = $2;
							$$->e = $5;
							DEBUG("[DoWhileStmt]");
						}
		;

defer_stmt
		: DEFER block
						{
							$$ = new DeferStmt();
							$$->b = $2;
							DEBUG("[Defer]");
						}
		;

label_stmt
		: IDENTIFIER ':'
						{
							$$ = new LabelStmt();
							$$->ident = $1;
							DEBUG("[Label]");
						}
		;

selection_stmt
		: if_else_stmt
						{
							$$ = new SelectionStmt();
							$$->type = SelectionStmt::types::IF_ELSE;
							$$->ies = $1;
							DEBUG("[SelectionStmt::IfElseStmt]");
						}
		| switch_stmt
						{
							$$ = new SelectionStmt();
							$$->type = SelectionStmt::types::SWITCH;
							$$->ss = $1;
							DEBUG("[SelectionStmt::SwitchStmt]");
						}
		;

if_else_stmt
		: if_block
						{
							$$ = new IfElseStmt();
							$$->if_block = $1;
							$$->else_block = NULL;
							DEBUG("[IfElseStmt::If]");
						}
		| if_block else_block
						{
							$$ = new IfElseStmt();
							$$->if_block = $1;
							$$->else_block = $2;
							DEBUG("[IfElseStmt::IfElse]");
						}
		;

if_block
		: IF '(' expression ')' block
						{
							$$ = new IfBlock();
							$$->e = $3;
							$$->b = $5;
							DEBUG("[IfElseStmt::IfBlock]");
						}
		;

else_block
		: ELSE if_else_stmt
						{
							$$ = new ElseBlock();
							$$->is_set_if_else = true;
							$$->if_else = $2;
							$$->b = NULL;
							DEBUG("[IfElseStmt::ElseIfBlock]");

						}
		| ELSE block
						{
							$$ = new ElseBlock();
							$$->is_set_if_else = false;
							$$->if_else = NULL;
							$$->b = $2;
							DEBUG("[IfElseStmt::ElseBlock]");
						}
		;

switch_stmt
		: SWITCH '(' expression ')' '{' case_blocks '}'
						{
							$$ = new SwitchStmt();
							$$->is_set_exp = true;
							$$->e = $3;
							$$->c = $6;
							DEBUG("[SwitchStmt::SwitchCase]");
						}
		| SWITCH  '{' case_blocks '}'
						{
							$$ = new SwitchStmt();
							$$->is_set_exp = false;
							$$->e = NULL;
							$$->c = $3;
							DEBUG("[SwitchStmt::SwitchCaseNoExp]");
						}
		;

case_blocks
		: %empty
						{
							/* empty */
						}
		| case_blocks case_block EOL
						{
							if (!$1) {
								$1 = new CaseBlocks();
							}
							if ($2->is_default) {
								if ($1->default_counter >= 1) {
									ERR("[SwitchStmt::CaseBlocks] More than 1 default block");
								}
								$1->default_counter++;
							}
							$1->case_block_list.push_back($2);
							$$ = $1;
							DEBUG("[SwitchStmt::CaseBlocks]");
						}
		;

case_block
		: CASE '(' case_expression_list ')' block
						{
							$$ = new CaseBlock();
							$$->is_default = false;
							$$->case_expr_list_ptr = $3;
							$$->block_ptr = $5;
							DEBUG("[CaseBlock::Expression]");
						}
		| DEFAULT block
						{
							$$ = new CaseBlock();
							$$->is_default = true;
							$$->block_ptr = $2;
							DEBUG("[CaseBlock::Default]");
						}
		;

case_expression_list
		: case_expression_list ',' expression
						{
							$1->expr_list.push_back($3);
							$$ = $1;
							DEBUG("[SwitchStmt::CaseExpression]");

						}
		| expression
						{
							$$ = new CaseExpressionList();
							$$->expr_list.push_back($1);
							DEBUG("[SwitchStmt::CaseExpression]");
						}
		;

jump_stmt
		: GOTO IDENTIFIER
						{
							$$ = new JumpStmt();
							$$->type = JumpStmt::types::GOTO;
							$$->goto_ident = $2;
							DEBUG("[Goto]");
						}
		| CONTINUE
						{
							$$ = new JumpStmt();
							$$->type = JumpStmt::types::CONTINUE;
							DEBUG("[Continue]");
						}
		| BREAK
						{
							$$ = new JumpStmt();
							$$->type = JumpStmt::types::BREAK;
							DEBUG("[Break]");
						}
		| RETURN return_expr
						{
							$$ = new JumpStmt();
							$$->type = JumpStmt::types::RETURN;
							$$->return_expr_ptr = $2;
							DEBUG("[Return]");
						}
		;

return_expr
		: %empty
						{
							/* Do nothing */
							$$ = new ReturnExpr();
							/* Pointer to empty ExpressionList */
							$$->expr_list_ptr = new ExpressionList();
							DEBUG("[ReturnExpr]");
						}
		| expression_list
						{
							$$ = new ReturnExpr();
							$$->expr_list_ptr = $1;
							DEBUG("[ReturnExpr]");
						}
		;

%%

int main() {
	// std::map<std::string, llvm::Value *> NamedValues; // Contains values defined in current scope

	// Make the module, which holds all the code.
	Module = std::make_unique<llvm::Module>("carbon module", Context);

	yy::Lexer lexer(std::cin);
	yy::parser parser(lexer);
	parser.parse();

	sf.codeGen();

	Module->print(llvm::errs(), nullptr);
	return 0;
}

void yy::parser::error(const location_type& loc, const std::string& msg) {
	std::cerr << "\033[31m" << msg << " @ " << "line=" << loc.begin.line
		<< " col=" << loc.begin.column << "\033[0m\n" << std::endl;
}
