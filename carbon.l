/*
bison -y -d carbon.y 				# output : y.tab.c  y.tab.h
reflex  --flex --bison carbon.l			# output : lex.yy.cpp
cc -Wall -Wunused -Wextra -c y.tab.c		# output : y.tab.o
c++ -Wall -Wunused -Wextra -o carbon y.tab.o lex.yy.cpp ~/reflex/lib/libreflex.a
*/

%top{
	#include <cstdio>
	#include <iostream>
	#include <iomanip>
	#include "y.tab.h"	/* Generated by bison. */
	#define YY_EXTERN_C extern "C"
	using namespace std;
%}

%class{
%}

%init{
%}

%option bison noyywrap
%option unicode

bin_digit		[0-1]
oct_digit		[0-7]
dec_digit		[0-9]
hex_digit		[0-9A-F]

bin_lit			("+"|"-")?"2x"{bin_digit}+
oct_lit			("+"|"-")?"8x"{oct_digit}+
dec_lit			("+"|"-")?("10x")?{dec_digit}+
hex_lit			("+"|"-")?"16x"{hex_digit}+

float_exp		("e"|"E")("+"|"-")?{dec_digit}+
float_1			{dec_digit}+"."{dec_digit}*{float_exp}?
float_2			{dec_digit}+{float_exp}
float_3			"."{dec_digit}+{float_exp}
float_lit		("+"|"-")?{float_1}|{float_2}|{float_3}

escape_char		\\("a"|"b"|"f"|"n"|"r"|"t"|"v")
char_lit		"'"([a-zA-z]|{escape_char})"'"|[0-255]


raw_str_lit		"r"("'".*"'"|\".*\")
h_raw_str_lit		"r"("'''".*"'''"|\"\"\".*\"\"\")
h_itr_str_lit		("'''".*"'''"|\"\"\".*\"\"\")
str_lit			{raw_str_lit}|{h_raw_str_lit}|{h_itr_str_lit}

letter			[a-zA-Z]
ident			{letter}({letter}|{dec_digit})*

%%

"/*".*"*/"							{ return COMMENT; }

"module"							{ return MODULE; }
"import"							{ return IMPORT; }
"from"								{ return FROM; }
"as"								{ return AS; }

"def"								{ return DEF; }

"("								{ return '('; }
")"								{ return ')'; }
"["								{ return '['; }
"]"								{ return ']'; }
"{"								{ return '{'; }
"}"								{ return '}'; }
"->"								{ return DASH_GREATER; }
"."								{ return '.'; }
":"								{ return ':'; }
";"								{ return ';'; }
","								{ return ','; }
"..."								{ printf("[ ... ]"); }

"register"							{ printf("[ STORAGE_CLASS:register ]"); }
"static"							{ printf("[ STORAGE_CLASS:static ]"); }
"const"								{ printf("[ TYPE_QUALIFIER:const ]"); }
"volatile"							{ printf("[ TYPE_QUALIFIER:volatile ]"); }
"restrict"							{ printf("[ TYPE_QUALIFIER:restrict ]"); }
"atomic"							{ printf("[ TYPE_QUALIFIER:atomic ]"); }

"bool"								{ return BOOL; }
"char"								{ return CHAR; }
"byte"								{ return BYTE; }
"int"								{ return INT; }
"int8"								{ return INT8; }
"int16"								{ return INT16; }
"int32"								{ return INT32; }
"int64"								{ return INT64; }
"uint"								{ return UINT; }
"uint8"								{ return UINT8; }
"uint16"							{ return UINT16; }
"uint32"							{ return UINT32; }
"uint64"							{ return UINT64; }
"float32"							{ return FLOAT32; }
"float64"							{ return FLOAT64; }
"float128"							{ return FLOAT128; }

"string"							{ return BOOL; }

"ptr"								{ return BOOL; }

"true"								{ printf("[ LIT:true ]"); }
"false"								{ printf("[ LIT:false ]"); }

"type"								{ printf("[ TYPE:type ]"); }
"struct"							{ printf("[ TYPE:struct ]"); }
"union"								{ printf("[ TYPE:union ]"); }
"enum"								{ printf("[ TYPE:enum ]"); }
"option"							{ printf("[ TYPE:option ]"); }

{bin_lit}							{ printf("[ LIT:binary ]"); }
{oct_lit}							{ printf("[ LIT:octal ]"); }
{dec_lit}							{ printf("[ LIT:decimal ]"); }
{hex_lit}							{ printf("[ LIT:hex ]"); }

{float_lit}							{ printf("[ LIT:float ]"); }

{char_lit}							{ printf("[ LIT:char ]"); }

\"[^"]*\"							{ return STR1_LITERAL; printf("[ LIT:str1 ]"); }
\'[^']*\'							{ return STR2_LITERAL; printf("[ LIT:str2 ]"); }
{str_lit}							{ printf("[ LIT:string ]"); }

"null"|{hex_lit}|{bin_lit}					{ printf("[ LIT:pointer ]"); }

"+"								{ printf("[ OP:B:AR:+ ]"); }
"-"								{ printf("[ OP:B:AR:- ]"); }
"*"								{ printf("[ OP:B:AR:* ]"); }
"/"								{ printf("[ OP:B:AR:/ ]"); }
"%"								{ printf("[ OP:B:AR:%% ]"); }
"=="								{ printf("[ OP:B:RL:== ]"); }
"!="								{ printf("[ OP:B:RL:!= ]"); }
"<"								{ printf("[ OP:B:RL:< ]"); }
">"								{ printf("[ OP:B:RL:> ]"); }
"<="								{ printf("[ OP:B:RL:<= ]"); }
">="								{ printf("[ OP:B:RL:>= ]"); }
">>"								{ printf("[ OP:B:SH:>> ]"); }
"<<"								{ printf("[ OP:B:SH:<< ]"); }
">>>"								{ printf("[ OP:B:SH:>>> ]"); }
"<<<"								{ printf("[ OP:B:SH:<<< ]"); }
"||"								{ printf("[ OP:B:LG:|| ]"); }
"&&"								{ printf("[ OP:B:LG:&& ]"); }
"&"								{ printf("[ OP:B:BT:& ]"); }
"|"								{ printf("[ OP:B:BT:| ]"); }
"^"								{ printf("[ OP:B:BT:^ ]"); }
"&^"								{ printf("[ OP:B:BT:&^ ]"); }

"!"								{ printf("[ OP:U:L:! ]"); }
"~"								{ printf("[ OP:U:L:~ ]"); }
"@"								{ printf("[ OP:U:L:@ ]"); }
"++"								{ printf("[ OP:U:R:++ ]"); }
"--"								{ printf("[ OP:U:R:-- ]"); }

"="								{ printf("[ OP:B:AS:= ]"); }

"public"							{ printf("[ ASC_MOD:public ]"); }
"private"							{ printf("[ ASC_MOD:private ]"); }

"return"							{ printf("[ STMT:return ]"); }
"break"								{ printf("[ STMT:break ]"); }
"continue"							{ printf("[ STMT:continue ]"); }
"goto"								{ printf("[ STMT:goto ]"); }
"fallthrough"							{ printf("[ STMT:fallthrough ]"); }
"if"								{ printf("[ STMT:if ]"); }
"else"								{ printf("[ STMT:else ]"); }
"for"								{ printf("[ STMT:for ]"); }
"while"								{ printf("[ STMT:while ]"); }
"do"								{ printf("[ STMT:do ]"); }
"defer"								{ printf("[ STMT:defer ]"); }
"extend"							{ printf("[ STMT:extend ]"); }

{ident}								{ return IDENTIFIER; printf("[ IDENTIFIER ]"); }


%%

//int main(int argc, char **argv) {
//	FILE *fd = stdin;
//	if (argc > 1 && (fd = fopen(argv[1], "r")) == NULL) {
//		exit(EXIT_FAILURE);
//	}
//
//	// create a lexer that consumes a file or reads stdin
//	Lexer lexer(fd);
//
//	// here we go!
//	lexer.lex();
//
//	if (fd != stdin)
//		fclose(fd);
//	return 0;
//}
